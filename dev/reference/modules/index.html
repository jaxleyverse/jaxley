
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://jaxleyverse.github.io/jaxley/dev/reference/modules/">
      
      
        <link rel="prev" href="../../code_of_conduct/">
      
      
        <link rel="next" href="../integration/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.11">
    
    
      
        <title>Modules - Jaxley</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.4af4bdda.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Jaxley" class="md-header__button md-logo" aria-label="Jaxley" data-md-component="logo">
      
  <img src="../../logo_white.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Jaxley
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Modules
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="http://github.com/jaxleyverse/jaxley" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    jaxleyverse/jaxley
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Jaxley" class="md-nav__button md-logo" aria-label="Jaxley" data-md-component="logo">
      
  <img src="../../logo_white.png" alt="logo">

    </a>
    Jaxley
  </label>
  
    <div class="md-nav__source">
      <a href="http://github.com/jaxleyverse/jaxley" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    jaxleyverse/jaxley
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Tutorials
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/01_morph_neurons/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Getting started
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/02_small_network/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Run a network simulation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/03_setting_parameters.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Set parameters
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/04_jit_and_vmap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Accelerate simulations
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/05_channel_and_synapse_models/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Define your own channels
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/06_groups/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Define groups
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/08_importing_morphologies/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Read and handle SWC files
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/07_gradient_descent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Training models
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Contributing
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Contributing
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contribute/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Guide
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../code_of_conduct/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Code of Conduct
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Modules
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Modules
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Module">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.branches" class="md-nav__link">
    <span class="md-ellipsis">
      branches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.cells" class="md-nav__link">
    <span class="md-ellipsis">
      cells
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.comps" class="md-nav__link">
    <span class="md-ellipsis">
      comps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.initialized" class="md-nav__link">
    <span class="md-ellipsis">
      initialized
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.shape" class="md-nav__link">
    <span class="md-ellipsis">
      shape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.view" class="md-nav__link">
    <span class="md-ellipsis">
      view
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      __iter__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.add_to_group" class="md-nav__link">
    <span class="md-ellipsis">
      add_to_group
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.branch" class="md-nav__link">
    <span class="md-ellipsis">
      branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.cell" class="md-nav__link">
    <span class="md-ellipsis">
      cell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.clamp" class="md-nav__link">
    <span class="md-ellipsis">
      clamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.comp" class="md-nav__link">
    <span class="md-ellipsis">
      comp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.compute_compartment_centers" class="md-nav__link">
    <span class="md-ellipsis">
      compute_compartment_centers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.compute_xyz" class="md-nav__link">
    <span class="md-ellipsis">
      compute_xyz
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.copy" class="md-nav__link">
    <span class="md-ellipsis">
      copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.copy_node_property_to_edges" class="md-nav__link">
    <span class="md-ellipsis">
      copy_node_property_to_edges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_clamp" class="md-nav__link">
    <span class="md-ellipsis">
      data_clamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_set" class="md-nav__link">
    <span class="md-ellipsis">
      data_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      data_stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete" class="md-nav__link">
    <span class="md-ellipsis">
      delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_clamps" class="md-nav__link">
    <span class="md-ellipsis">
      delete_clamps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_diffusion" class="md-nav__link">
    <span class="md-ellipsis">
      delete_diffusion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_recordings" class="md-nav__link">
    <span class="md-ellipsis">
      delete_recordings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_stimuli" class="md-nav__link">
    <span class="md-ellipsis">
      delete_stimuli
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_trainables" class="md-nav__link">
    <span class="md-ellipsis">
      delete_trainables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.diffuse" class="md-nav__link">
    <span class="md-ellipsis">
      diffuse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.distance" class="md-nav__link">
    <span class="md-ellipsis">
      distance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.edge" class="md-nav__link">
    <span class="md-ellipsis">
      edge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_states" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.init_states" class="md-nav__link">
    <span class="md-ellipsis">
      init_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.loc" class="md-nav__link">
    <span class="md-ellipsis">
      loc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.make_trainable" class="md-nav__link">
    <span class="md-ellipsis">
      make_trainable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move" class="md-nav__link">
    <span class="md-ellipsis">
      move
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move_to" class="md-nav__link">
    <span class="md-ellipsis">
      move_to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.rotate" class="md-nav__link">
    <span class="md-ellipsis">
      rotate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.scope" class="md-nav__link">
    <span class="md-ellipsis">
      scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.select" class="md-nav__link">
    <span class="md-ellipsis">
      select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set_ncomp" class="md-nav__link">
    <span class="md-ellipsis">
      set_ncomp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set_scope" class="md-nav__link">
    <span class="md-ellipsis">
      set_scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.show" class="md-nav__link">
    <span class="md-ellipsis">
      show
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.step" class="md-nav__link">
    <span class="md-ellipsis">
      step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.to_jax" class="md-nav__link">
    <span class="md-ellipsis">
      to_jax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.write_trainables" class="md-nav__link">
    <span class="md-ellipsis">
      write_trainables
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Compartment">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.compartment.Compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Branch">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.arrange_in_layers" class="md-nav__link">
    <span class="md-ellipsis">
      arrange_in_layers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../integration/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Simulation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mechanisms/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Mechansims
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../connect/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Connecting Cells
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../optimize/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Optimization
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Utils
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../faq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../credits/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Credits
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Module">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.branches" class="md-nav__link">
    <span class="md-ellipsis">
      branches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.cells" class="md-nav__link">
    <span class="md-ellipsis">
      cells
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.comps" class="md-nav__link">
    <span class="md-ellipsis">
      comps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.initialized" class="md-nav__link">
    <span class="md-ellipsis">
      initialized
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.shape" class="md-nav__link">
    <span class="md-ellipsis">
      shape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.view" class="md-nav__link">
    <span class="md-ellipsis">
      view
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.__iter__" class="md-nav__link">
    <span class="md-ellipsis">
      __iter__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.add_to_group" class="md-nav__link">
    <span class="md-ellipsis">
      add_to_group
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.branch" class="md-nav__link">
    <span class="md-ellipsis">
      branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.cell" class="md-nav__link">
    <span class="md-ellipsis">
      cell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.clamp" class="md-nav__link">
    <span class="md-ellipsis">
      clamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.comp" class="md-nav__link">
    <span class="md-ellipsis">
      comp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.compute_compartment_centers" class="md-nav__link">
    <span class="md-ellipsis">
      compute_compartment_centers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.compute_xyz" class="md-nav__link">
    <span class="md-ellipsis">
      compute_xyz
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.copy" class="md-nav__link">
    <span class="md-ellipsis">
      copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.copy_node_property_to_edges" class="md-nav__link">
    <span class="md-ellipsis">
      copy_node_property_to_edges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_clamp" class="md-nav__link">
    <span class="md-ellipsis">
      data_clamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_set" class="md-nav__link">
    <span class="md-ellipsis">
      data_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      data_stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete" class="md-nav__link">
    <span class="md-ellipsis">
      delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_clamps" class="md-nav__link">
    <span class="md-ellipsis">
      delete_clamps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_diffusion" class="md-nav__link">
    <span class="md-ellipsis">
      delete_diffusion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_recordings" class="md-nav__link">
    <span class="md-ellipsis">
      delete_recordings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_stimuli" class="md-nav__link">
    <span class="md-ellipsis">
      delete_stimuli
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_trainables" class="md-nav__link">
    <span class="md-ellipsis">
      delete_trainables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.diffuse" class="md-nav__link">
    <span class="md-ellipsis">
      diffuse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.distance" class="md-nav__link">
    <span class="md-ellipsis">
      distance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.edge" class="md-nav__link">
    <span class="md-ellipsis">
      edge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_states" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.init_states" class="md-nav__link">
    <span class="md-ellipsis">
      init_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.loc" class="md-nav__link">
    <span class="md-ellipsis">
      loc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.make_trainable" class="md-nav__link">
    <span class="md-ellipsis">
      make_trainable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move" class="md-nav__link">
    <span class="md-ellipsis">
      move
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move_to" class="md-nav__link">
    <span class="md-ellipsis">
      move_to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.rotate" class="md-nav__link">
    <span class="md-ellipsis">
      rotate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.scope" class="md-nav__link">
    <span class="md-ellipsis">
      scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.select" class="md-nav__link">
    <span class="md-ellipsis">
      select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set_ncomp" class="md-nav__link">
    <span class="md-ellipsis">
      set_ncomp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set_scope" class="md-nav__link">
    <span class="md-ellipsis">
      set_scope
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.show" class="md-nav__link">
    <span class="md-ellipsis">
      show
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.step" class="md-nav__link">
    <span class="md-ellipsis">
      step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.to_jax" class="md-nav__link">
    <span class="md-ellipsis">
      to_jax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.write_trainables" class="md-nav__link">
    <span class="md-ellipsis">
      write_trainables
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Compartment">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.compartment.Compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Branch">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.arrange_in_layers" class="md-nav__link">
    <span class="md-ellipsis">
      arrange_in_layers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


  <h1>Modules</h1>

<h2 id="module">Module<a class="headerlink" href="#module" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.base.Module"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>


        <p>Module base class.</p>
<p>Modules are everything that can be passed to <code>jx.integrate</code>, i.e. compartments,
branches, cells, and networks.</p>
<p>This base class defines the scaffold for all jaxley modules (compartments,
branches, cells, networks).</p>
<p>Modules can be traversed and modified using the <code>at</code>, <code>cell</code>, <code>branch</code>, <code>comp</code>,
<code>edge</code>, and <code>loc</code> methods. The <code>scope</code> method can be used to toggle between
global and local indices. Traversal of Modules will return a <code>View</code> of itself,
that has a modified set of attributes, which only consider the part of the Module
that is in view.</p>
<p>For developers: The above has consequences for how to operate on <code>Module</code> and which
changes take affect where. The following guidelines should be followed (copied from
<code>View</code>):</p>
<ol>
<li>We consider a Module to have everything in view.</li>
<li>Views can display and keep track of how a module is traversed. But(!),
   do not support making changes or setting variables. This still has to be
   done in the base Module, i.e. <code>self.base</code>. In order to enssure that these
   changes only affects whatever is currently in view <code>self._nodes_in_view</code>,
   or <code>self._edges_in_view</code> among others have to be used. Operating on nodes
   currently in view can for example be done with
   <code>self.base.node.loc[self._nodes_in_view]</code>.</li>
<li>Every attribute of Module that changes based on what&rsquo;s in view, i.e. <code>xyzr</code>,
   needs to modified when View is instantiated. I.e. <code>xyzr</code> of <code>cell.branch(0)</code>,
   should be <code>[self.base.xyzr[0]]</code> This could be achieved via:
   <code>[self.base.xyzr[b] for b in self._branches_in_view]</code>.</li>
</ol>
<p>For developers: If you want to add a new method to <code>Module</code>, here is an example of
how to make methods of Module compatible with View:</p>
<p>.. code-block:: python</p>
<div class="codehilite"><pre><span></span><code># Use data in view to return something.
def count_small_branches(self):
    # no need to use self.base.attr + viewed indices,
    # since no change is made to the attr in question (nodes)
    comp_lens = self.nodes[&quot;length&quot;]
    branch_lens = comp_lens.groupby(&quot;global_branch_index&quot;).sum()
    return np.sum(branch_lens &lt; 10)

# Change data in view.
def change_attr_in_view(self):
    # changes to attrs have to be made via self.base.attr + viewed indices
    a = func1(self.base.attr1[self._cells_in_view])
    b = func2(self.base.attr2[self._edges_in_view])
    self.base.attr3[self._branches_in_view] = a + b
</code></pre></div>







              <details class="quote">
                <summary>Source code in <code>jaxley/modules/base.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  63</span>
<span class="normal">  64</span>
<span class="normal">  65</span>
<span class="normal">  66</span>
<span class="normal">  67</span>
<span class="normal">  68</span>
<span class="normal">  69</span>
<span class="normal">  70</span>
<span class="normal">  71</span>
<span class="normal">  72</span>
<span class="normal">  73</span>
<span class="normal">  74</span>
<span class="normal">  75</span>
<span class="normal">  76</span>
<span class="normal">  77</span>
<span class="normal">  78</span>
<span class="normal">  79</span>
<span class="normal">  80</span>
<span class="normal">  81</span>
<span class="normal">  82</span>
<span class="normal">  83</span>
<span class="normal">  84</span>
<span class="normal">  85</span>
<span class="normal">  86</span>
<span class="normal">  87</span>
<span class="normal">  88</span>
<span class="normal">  89</span>
<span class="normal">  90</span>
<span class="normal">  91</span>
<span class="normal">  92</span>
<span class="normal">  93</span>
<span class="normal">  94</span>
<span class="normal">  95</span>
<span class="normal">  96</span>
<span class="normal">  97</span>
<span class="normal">  98</span>
<span class="normal">  99</span>
<span class="normal"> 100</span>
<span class="normal"> 101</span>
<span class="normal"> 102</span>
<span class="normal"> 103</span>
<span class="normal"> 104</span>
<span class="normal"> 105</span>
<span class="normal"> 106</span>
<span class="normal"> 107</span>
<span class="normal"> 108</span>
<span class="normal"> 109</span>
<span class="normal"> 110</span>
<span class="normal"> 111</span>
<span class="normal"> 112</span>
<span class="normal"> 113</span>
<span class="normal"> 114</span>
<span class="normal"> 115</span>
<span class="normal"> 116</span>
<span class="normal"> 117</span>
<span class="normal"> 118</span>
<span class="normal"> 119</span>
<span class="normal"> 120</span>
<span class="normal"> 121</span>
<span class="normal"> 122</span>
<span class="normal"> 123</span>
<span class="normal"> 124</span>
<span class="normal"> 125</span>
<span class="normal"> 126</span>
<span class="normal"> 127</span>
<span class="normal"> 128</span>
<span class="normal"> 129</span>
<span class="normal"> 130</span>
<span class="normal"> 131</span>
<span class="normal"> 132</span>
<span class="normal"> 133</span>
<span class="normal"> 134</span>
<span class="normal"> 135</span>
<span class="normal"> 136</span>
<span class="normal"> 137</span>
<span class="normal"> 138</span>
<span class="normal"> 139</span>
<span class="normal"> 140</span>
<span class="normal"> 141</span>
<span class="normal"> 142</span>
<span class="normal"> 143</span>
<span class="normal"> 144</span>
<span class="normal"> 145</span>
<span class="normal"> 146</span>
<span class="normal"> 147</span>
<span class="normal"> 148</span>
<span class="normal"> 149</span>
<span class="normal"> 150</span>
<span class="normal"> 151</span>
<span class="normal"> 152</span>
<span class="normal"> 153</span>
<span class="normal"> 154</span>
<span class="normal"> 155</span>
<span class="normal"> 156</span>
<span class="normal"> 157</span>
<span class="normal"> 158</span>
<span class="normal"> 159</span>
<span class="normal"> 160</span>
<span class="normal"> 161</span>
<span class="normal"> 162</span>
<span class="normal"> 163</span>
<span class="normal"> 164</span>
<span class="normal"> 165</span>
<span class="normal"> 166</span>
<span class="normal"> 167</span>
<span class="normal"> 168</span>
<span class="normal"> 169</span>
<span class="normal"> 170</span>
<span class="normal"> 171</span>
<span class="normal"> 172</span>
<span class="normal"> 173</span>
<span class="normal"> 174</span>
<span class="normal"> 175</span>
<span class="normal"> 176</span>
<span class="normal"> 177</span>
<span class="normal"> 178</span>
<span class="normal"> 179</span>
<span class="normal"> 180</span>
<span class="normal"> 181</span>
<span class="normal"> 182</span>
<span class="normal"> 183</span>
<span class="normal"> 184</span>
<span class="normal"> 185</span>
<span class="normal"> 186</span>
<span class="normal"> 187</span>
<span class="normal"> 188</span>
<span class="normal"> 189</span>
<span class="normal"> 190</span>
<span class="normal"> 191</span>
<span class="normal"> 192</span>
<span class="normal"> 193</span>
<span class="normal"> 194</span>
<span class="normal"> 195</span>
<span class="normal"> 196</span>
<span class="normal"> 197</span>
<span class="normal"> 198</span>
<span class="normal"> 199</span>
<span class="normal"> 200</span>
<span class="normal"> 201</span>
<span class="normal"> 202</span>
<span class="normal"> 203</span>
<span class="normal"> 204</span>
<span class="normal"> 205</span>
<span class="normal"> 206</span>
<span class="normal"> 207</span>
<span class="normal"> 208</span>
<span class="normal"> 209</span>
<span class="normal"> 210</span>
<span class="normal"> 211</span>
<span class="normal"> 212</span>
<span class="normal"> 213</span>
<span class="normal"> 214</span>
<span class="normal"> 215</span>
<span class="normal"> 216</span>
<span class="normal"> 217</span>
<span class="normal"> 218</span>
<span class="normal"> 219</span>
<span class="normal"> 220</span>
<span class="normal"> 221</span>
<span class="normal"> 222</span>
<span class="normal"> 223</span>
<span class="normal"> 224</span>
<span class="normal"> 225</span>
<span class="normal"> 226</span>
<span class="normal"> 227</span>
<span class="normal"> 228</span>
<span class="normal"> 229</span>
<span class="normal"> 230</span>
<span class="normal"> 231</span>
<span class="normal"> 232</span>
<span class="normal"> 233</span>
<span class="normal"> 234</span>
<span class="normal"> 235</span>
<span class="normal"> 236</span>
<span class="normal"> 237</span>
<span class="normal"> 238</span>
<span class="normal"> 239</span>
<span class="normal"> 240</span>
<span class="normal"> 241</span>
<span class="normal"> 242</span>
<span class="normal"> 243</span>
<span class="normal"> 244</span>
<span class="normal"> 245</span>
<span class="normal"> 246</span>
<span class="normal"> 247</span>
<span class="normal"> 248</span>
<span class="normal"> 249</span>
<span class="normal"> 250</span>
<span class="normal"> 251</span>
<span class="normal"> 252</span>
<span class="normal"> 253</span>
<span class="normal"> 254</span>
<span class="normal"> 255</span>
<span class="normal"> 256</span>
<span class="normal"> 257</span>
<span class="normal"> 258</span>
<span class="normal"> 259</span>
<span class="normal"> 260</span>
<span class="normal"> 261</span>
<span class="normal"> 262</span>
<span class="normal"> 263</span>
<span class="normal"> 264</span>
<span class="normal"> 265</span>
<span class="normal"> 266</span>
<span class="normal"> 267</span>
<span class="normal"> 268</span>
<span class="normal"> 269</span>
<span class="normal"> 270</span>
<span class="normal"> 271</span>
<span class="normal"> 272</span>
<span class="normal"> 273</span>
<span class="normal"> 274</span>
<span class="normal"> 275</span>
<span class="normal"> 276</span>
<span class="normal"> 277</span>
<span class="normal"> 278</span>
<span class="normal"> 279</span>
<span class="normal"> 280</span>
<span class="normal"> 281</span>
<span class="normal"> 282</span>
<span class="normal"> 283</span>
<span class="normal"> 284</span>
<span class="normal"> 285</span>
<span class="normal"> 286</span>
<span class="normal"> 287</span>
<span class="normal"> 288</span>
<span class="normal"> 289</span>
<span class="normal"> 290</span>
<span class="normal"> 291</span>
<span class="normal"> 292</span>
<span class="normal"> 293</span>
<span class="normal"> 294</span>
<span class="normal"> 295</span>
<span class="normal"> 296</span>
<span class="normal"> 297</span>
<span class="normal"> 298</span>
<span class="normal"> 299</span>
<span class="normal"> 300</span>
<span class="normal"> 301</span>
<span class="normal"> 302</span>
<span class="normal"> 303</span>
<span class="normal"> 304</span>
<span class="normal"> 305</span>
<span class="normal"> 306</span>
<span class="normal"> 307</span>
<span class="normal"> 308</span>
<span class="normal"> 309</span>
<span class="normal"> 310</span>
<span class="normal"> 311</span>
<span class="normal"> 312</span>
<span class="normal"> 313</span>
<span class="normal"> 314</span>
<span class="normal"> 315</span>
<span class="normal"> 316</span>
<span class="normal"> 317</span>
<span class="normal"> 318</span>
<span class="normal"> 319</span>
<span class="normal"> 320</span>
<span class="normal"> 321</span>
<span class="normal"> 322</span>
<span class="normal"> 323</span>
<span class="normal"> 324</span>
<span class="normal"> 325</span>
<span class="normal"> 326</span>
<span class="normal"> 327</span>
<span class="normal"> 328</span>
<span class="normal"> 329</span>
<span class="normal"> 330</span>
<span class="normal"> 331</span>
<span class="normal"> 332</span>
<span class="normal"> 333</span>
<span class="normal"> 334</span>
<span class="normal"> 335</span>
<span class="normal"> 336</span>
<span class="normal"> 337</span>
<span class="normal"> 338</span>
<span class="normal"> 339</span>
<span class="normal"> 340</span>
<span class="normal"> 341</span>
<span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span>
<span class="normal">1518</span>
<span class="normal">1519</span>
<span class="normal">1520</span>
<span class="normal">1521</span>
<span class="normal">1522</span>
<span class="normal">1523</span>
<span class="normal">1524</span>
<span class="normal">1525</span>
<span class="normal">1526</span>
<span class="normal">1527</span>
<span class="normal">1528</span>
<span class="normal">1529</span>
<span class="normal">1530</span>
<span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span>
<span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span>
<span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span>
<span class="normal">1743</span>
<span class="normal">1744</span>
<span class="normal">1745</span>
<span class="normal">1746</span>
<span class="normal">1747</span>
<span class="normal">1748</span>
<span class="normal">1749</span>
<span class="normal">1750</span>
<span class="normal">1751</span>
<span class="normal">1752</span>
<span class="normal">1753</span>
<span class="normal">1754</span>
<span class="normal">1755</span>
<span class="normal">1756</span>
<span class="normal">1757</span>
<span class="normal">1758</span>
<span class="normal">1759</span>
<span class="normal">1760</span>
<span class="normal">1761</span>
<span class="normal">1762</span>
<span class="normal">1763</span>
<span class="normal">1764</span>
<span class="normal">1765</span>
<span class="normal">1766</span>
<span class="normal">1767</span>
<span class="normal">1768</span>
<span class="normal">1769</span>
<span class="normal">1770</span>
<span class="normal">1771</span>
<span class="normal">1772</span>
<span class="normal">1773</span>
<span class="normal">1774</span>
<span class="normal">1775</span>
<span class="normal">1776</span>
<span class="normal">1777</span>
<span class="normal">1778</span>
<span class="normal">1779</span>
<span class="normal">1780</span>
<span class="normal">1781</span>
<span class="normal">1782</span>
<span class="normal">1783</span>
<span class="normal">1784</span>
<span class="normal">1785</span>
<span class="normal">1786</span>
<span class="normal">1787</span>
<span class="normal">1788</span>
<span class="normal">1789</span>
<span class="normal">1790</span>
<span class="normal">1791</span>
<span class="normal">1792</span>
<span class="normal">1793</span>
<span class="normal">1794</span>
<span class="normal">1795</span>
<span class="normal">1796</span>
<span class="normal">1797</span>
<span class="normal">1798</span>
<span class="normal">1799</span>
<span class="normal">1800</span>
<span class="normal">1801</span>
<span class="normal">1802</span>
<span class="normal">1803</span>
<span class="normal">1804</span>
<span class="normal">1805</span>
<span class="normal">1806</span>
<span class="normal">1807</span>
<span class="normal">1808</span>
<span class="normal">1809</span>
<span class="normal">1810</span>
<span class="normal">1811</span>
<span class="normal">1812</span>
<span class="normal">1813</span>
<span class="normal">1814</span>
<span class="normal">1815</span>
<span class="normal">1816</span>
<span class="normal">1817</span>
<span class="normal">1818</span>
<span class="normal">1819</span>
<span class="normal">1820</span>
<span class="normal">1821</span>
<span class="normal">1822</span>
<span class="normal">1823</span>
<span class="normal">1824</span>
<span class="normal">1825</span>
<span class="normal">1826</span>
<span class="normal">1827</span>
<span class="normal">1828</span>
<span class="normal">1829</span>
<span class="normal">1830</span>
<span class="normal">1831</span>
<span class="normal">1832</span>
<span class="normal">1833</span>
<span class="normal">1834</span>
<span class="normal">1835</span>
<span class="normal">1836</span>
<span class="normal">1837</span>
<span class="normal">1838</span>
<span class="normal">1839</span>
<span class="normal">1840</span>
<span class="normal">1841</span>
<span class="normal">1842</span>
<span class="normal">1843</span>
<span class="normal">1844</span>
<span class="normal">1845</span>
<span class="normal">1846</span>
<span class="normal">1847</span>
<span class="normal">1848</span>
<span class="normal">1849</span>
<span class="normal">1850</span>
<span class="normal">1851</span>
<span class="normal">1852</span>
<span class="normal">1853</span>
<span class="normal">1854</span>
<span class="normal">1855</span>
<span class="normal">1856</span>
<span class="normal">1857</span>
<span class="normal">1858</span>
<span class="normal">1859</span>
<span class="normal">1860</span>
<span class="normal">1861</span>
<span class="normal">1862</span>
<span class="normal">1863</span>
<span class="normal">1864</span>
<span class="normal">1865</span>
<span class="normal">1866</span>
<span class="normal">1867</span>
<span class="normal">1868</span>
<span class="normal">1869</span>
<span class="normal">1870</span>
<span class="normal">1871</span>
<span class="normal">1872</span>
<span class="normal">1873</span>
<span class="normal">1874</span>
<span class="normal">1875</span>
<span class="normal">1876</span>
<span class="normal">1877</span>
<span class="normal">1878</span>
<span class="normal">1879</span>
<span class="normal">1880</span>
<span class="normal">1881</span>
<span class="normal">1882</span>
<span class="normal">1883</span>
<span class="normal">1884</span>
<span class="normal">1885</span>
<span class="normal">1886</span>
<span class="normal">1887</span>
<span class="normal">1888</span>
<span class="normal">1889</span>
<span class="normal">1890</span>
<span class="normal">1891</span>
<span class="normal">1892</span>
<span class="normal">1893</span>
<span class="normal">1894</span>
<span class="normal">1895</span>
<span class="normal">1896</span>
<span class="normal">1897</span>
<span class="normal">1898</span>
<span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span>
<span class="normal">1910</span>
<span class="normal">1911</span>
<span class="normal">1912</span>
<span class="normal">1913</span>
<span class="normal">1914</span>
<span class="normal">1915</span>
<span class="normal">1916</span>
<span class="normal">1917</span>
<span class="normal">1918</span>
<span class="normal">1919</span>
<span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span>
<span class="normal">1946</span>
<span class="normal">1947</span>
<span class="normal">1948</span>
<span class="normal">1949</span>
<span class="normal">1950</span>
<span class="normal">1951</span>
<span class="normal">1952</span>
<span class="normal">1953</span>
<span class="normal">1954</span>
<span class="normal">1955</span>
<span class="normal">1956</span>
<span class="normal">1957</span>
<span class="normal">1958</span>
<span class="normal">1959</span>
<span class="normal">1960</span>
<span class="normal">1961</span>
<span class="normal">1962</span>
<span class="normal">1963</span>
<span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span>
<span class="normal">1981</span>
<span class="normal">1982</span>
<span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span>
<span class="normal">2000</span>
<span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span>
<span class="normal">2011</span>
<span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span>
<span class="normal">2015</span>
<span class="normal">2016</span>
<span class="normal">2017</span>
<span class="normal">2018</span>
<span class="normal">2019</span>
<span class="normal">2020</span>
<span class="normal">2021</span>
<span class="normal">2022</span>
<span class="normal">2023</span>
<span class="normal">2024</span>
<span class="normal">2025</span>
<span class="normal">2026</span>
<span class="normal">2027</span>
<span class="normal">2028</span>
<span class="normal">2029</span>
<span class="normal">2030</span>
<span class="normal">2031</span>
<span class="normal">2032</span>
<span class="normal">2033</span>
<span class="normal">2034</span>
<span class="normal">2035</span>
<span class="normal">2036</span>
<span class="normal">2037</span>
<span class="normal">2038</span>
<span class="normal">2039</span>
<span class="normal">2040</span>
<span class="normal">2041</span>
<span class="normal">2042</span>
<span class="normal">2043</span>
<span class="normal">2044</span>
<span class="normal">2045</span>
<span class="normal">2046</span>
<span class="normal">2047</span>
<span class="normal">2048</span>
<span class="normal">2049</span>
<span class="normal">2050</span>
<span class="normal">2051</span>
<span class="normal">2052</span>
<span class="normal">2053</span>
<span class="normal">2054</span>
<span class="normal">2055</span>
<span class="normal">2056</span>
<span class="normal">2057</span>
<span class="normal">2058</span>
<span class="normal">2059</span>
<span class="normal">2060</span>
<span class="normal">2061</span>
<span class="normal">2062</span>
<span class="normal">2063</span>
<span class="normal">2064</span>
<span class="normal">2065</span>
<span class="normal">2066</span>
<span class="normal">2067</span>
<span class="normal">2068</span>
<span class="normal">2069</span>
<span class="normal">2070</span>
<span class="normal">2071</span>
<span class="normal">2072</span>
<span class="normal">2073</span>
<span class="normal">2074</span>
<span class="normal">2075</span>
<span class="normal">2076</span>
<span class="normal">2077</span>
<span class="normal">2078</span>
<span class="normal">2079</span>
<span class="normal">2080</span>
<span class="normal">2081</span>
<span class="normal">2082</span>
<span class="normal">2083</span>
<span class="normal">2084</span>
<span class="normal">2085</span>
<span class="normal">2086</span>
<span class="normal">2087</span>
<span class="normal">2088</span>
<span class="normal">2089</span>
<span class="normal">2090</span>
<span class="normal">2091</span>
<span class="normal">2092</span>
<span class="normal">2093</span>
<span class="normal">2094</span>
<span class="normal">2095</span>
<span class="normal">2096</span>
<span class="normal">2097</span>
<span class="normal">2098</span>
<span class="normal">2099</span>
<span class="normal">2100</span>
<span class="normal">2101</span>
<span class="normal">2102</span>
<span class="normal">2103</span>
<span class="normal">2104</span>
<span class="normal">2105</span>
<span class="normal">2106</span>
<span class="normal">2107</span>
<span class="normal">2108</span>
<span class="normal">2109</span>
<span class="normal">2110</span>
<span class="normal">2111</span>
<span class="normal">2112</span>
<span class="normal">2113</span>
<span class="normal">2114</span>
<span class="normal">2115</span>
<span class="normal">2116</span>
<span class="normal">2117</span>
<span class="normal">2118</span>
<span class="normal">2119</span>
<span class="normal">2120</span>
<span class="normal">2121</span>
<span class="normal">2122</span>
<span class="normal">2123</span>
<span class="normal">2124</span>
<span class="normal">2125</span>
<span class="normal">2126</span>
<span class="normal">2127</span>
<span class="normal">2128</span>
<span class="normal">2129</span>
<span class="normal">2130</span>
<span class="normal">2131</span>
<span class="normal">2132</span>
<span class="normal">2133</span>
<span class="normal">2134</span>
<span class="normal">2135</span>
<span class="normal">2136</span>
<span class="normal">2137</span>
<span class="normal">2138</span>
<span class="normal">2139</span>
<span class="normal">2140</span>
<span class="normal">2141</span>
<span class="normal">2142</span>
<span class="normal">2143</span>
<span class="normal">2144</span>
<span class="normal">2145</span>
<span class="normal">2146</span>
<span class="normal">2147</span>
<span class="normal">2148</span>
<span class="normal">2149</span>
<span class="normal">2150</span>
<span class="normal">2151</span>
<span class="normal">2152</span>
<span class="normal">2153</span>
<span class="normal">2154</span>
<span class="normal">2155</span>
<span class="normal">2156</span>
<span class="normal">2157</span>
<span class="normal">2158</span>
<span class="normal">2159</span>
<span class="normal">2160</span>
<span class="normal">2161</span>
<span class="normal">2162</span>
<span class="normal">2163</span>
<span class="normal">2164</span>
<span class="normal">2165</span>
<span class="normal">2166</span>
<span class="normal">2167</span>
<span class="normal">2168</span>
<span class="normal">2169</span>
<span class="normal">2170</span>
<span class="normal">2171</span>
<span class="normal">2172</span>
<span class="normal">2173</span>
<span class="normal">2174</span>
<span class="normal">2175</span>
<span class="normal">2176</span>
<span class="normal">2177</span>
<span class="normal">2178</span>
<span class="normal">2179</span>
<span class="normal">2180</span>
<span class="normal">2181</span>
<span class="normal">2182</span>
<span class="normal">2183</span>
<span class="normal">2184</span>
<span class="normal">2185</span>
<span class="normal">2186</span>
<span class="normal">2187</span>
<span class="normal">2188</span>
<span class="normal">2189</span>
<span class="normal">2190</span>
<span class="normal">2191</span>
<span class="normal">2192</span>
<span class="normal">2193</span>
<span class="normal">2194</span>
<span class="normal">2195</span>
<span class="normal">2196</span>
<span class="normal">2197</span>
<span class="normal">2198</span>
<span class="normal">2199</span>
<span class="normal">2200</span>
<span class="normal">2201</span>
<span class="normal">2202</span>
<span class="normal">2203</span>
<span class="normal">2204</span>
<span class="normal">2205</span>
<span class="normal">2206</span>
<span class="normal">2207</span>
<span class="normal">2208</span>
<span class="normal">2209</span>
<span class="normal">2210</span>
<span class="normal">2211</span>
<span class="normal">2212</span>
<span class="normal">2213</span>
<span class="normal">2214</span>
<span class="normal">2215</span>
<span class="normal">2216</span>
<span class="normal">2217</span>
<span class="normal">2218</span>
<span class="normal">2219</span>
<span class="normal">2220</span>
<span class="normal">2221</span>
<span class="normal">2222</span>
<span class="normal">2223</span>
<span class="normal">2224</span>
<span class="normal">2225</span>
<span class="normal">2226</span>
<span class="normal">2227</span>
<span class="normal">2228</span>
<span class="normal">2229</span>
<span class="normal">2230</span>
<span class="normal">2231</span>
<span class="normal">2232</span>
<span class="normal">2233</span>
<span class="normal">2234</span>
<span class="normal">2235</span>
<span class="normal">2236</span>
<span class="normal">2237</span>
<span class="normal">2238</span>
<span class="normal">2239</span>
<span class="normal">2240</span>
<span class="normal">2241</span>
<span class="normal">2242</span>
<span class="normal">2243</span>
<span class="normal">2244</span>
<span class="normal">2245</span>
<span class="normal">2246</span>
<span class="normal">2247</span>
<span class="normal">2248</span>
<span class="normal">2249</span>
<span class="normal">2250</span>
<span class="normal">2251</span>
<span class="normal">2252</span>
<span class="normal">2253</span>
<span class="normal">2254</span>
<span class="normal">2255</span>
<span class="normal">2256</span>
<span class="normal">2257</span>
<span class="normal">2258</span>
<span class="normal">2259</span>
<span class="normal">2260</span>
<span class="normal">2261</span>
<span class="normal">2262</span>
<span class="normal">2263</span>
<span class="normal">2264</span>
<span class="normal">2265</span>
<span class="normal">2266</span>
<span class="normal">2267</span>
<span class="normal">2268</span>
<span class="normal">2269</span>
<span class="normal">2270</span>
<span class="normal">2271</span>
<span class="normal">2272</span>
<span class="normal">2273</span>
<span class="normal">2274</span>
<span class="normal">2275</span>
<span class="normal">2276</span>
<span class="normal">2277</span>
<span class="normal">2278</span>
<span class="normal">2279</span>
<span class="normal">2280</span>
<span class="normal">2281</span>
<span class="normal">2282</span>
<span class="normal">2283</span>
<span class="normal">2284</span>
<span class="normal">2285</span>
<span class="normal">2286</span>
<span class="normal">2287</span>
<span class="normal">2288</span>
<span class="normal">2289</span>
<span class="normal">2290</span>
<span class="normal">2291</span>
<span class="normal">2292</span>
<span class="normal">2293</span>
<span class="normal">2294</span>
<span class="normal">2295</span>
<span class="normal">2296</span>
<span class="normal">2297</span>
<span class="normal">2298</span>
<span class="normal">2299</span>
<span class="normal">2300</span>
<span class="normal">2301</span>
<span class="normal">2302</span>
<span class="normal">2303</span>
<span class="normal">2304</span>
<span class="normal">2305</span>
<span class="normal">2306</span>
<span class="normal">2307</span>
<span class="normal">2308</span>
<span class="normal">2309</span>
<span class="normal">2310</span>
<span class="normal">2311</span>
<span class="normal">2312</span>
<span class="normal">2313</span>
<span class="normal">2314</span>
<span class="normal">2315</span>
<span class="normal">2316</span>
<span class="normal">2317</span>
<span class="normal">2318</span>
<span class="normal">2319</span>
<span class="normal">2320</span>
<span class="normal">2321</span>
<span class="normal">2322</span>
<span class="normal">2323</span>
<span class="normal">2324</span>
<span class="normal">2325</span>
<span class="normal">2326</span>
<span class="normal">2327</span>
<span class="normal">2328</span>
<span class="normal">2329</span>
<span class="normal">2330</span>
<span class="normal">2331</span>
<span class="normal">2332</span>
<span class="normal">2333</span>
<span class="normal">2334</span>
<span class="normal">2335</span>
<span class="normal">2336</span>
<span class="normal">2337</span>
<span class="normal">2338</span>
<span class="normal">2339</span>
<span class="normal">2340</span>
<span class="normal">2341</span>
<span class="normal">2342</span>
<span class="normal">2343</span>
<span class="normal">2344</span>
<span class="normal">2345</span>
<span class="normal">2346</span>
<span class="normal">2347</span>
<span class="normal">2348</span>
<span class="normal">2349</span>
<span class="normal">2350</span>
<span class="normal">2351</span>
<span class="normal">2352</span>
<span class="normal">2353</span>
<span class="normal">2354</span>
<span class="normal">2355</span>
<span class="normal">2356</span>
<span class="normal">2357</span>
<span class="normal">2358</span>
<span class="normal">2359</span>
<span class="normal">2360</span>
<span class="normal">2361</span>
<span class="normal">2362</span>
<span class="normal">2363</span>
<span class="normal">2364</span>
<span class="normal">2365</span>
<span class="normal">2366</span>
<span class="normal">2367</span>
<span class="normal">2368</span>
<span class="normal">2369</span>
<span class="normal">2370</span>
<span class="normal">2371</span>
<span class="normal">2372</span>
<span class="normal">2373</span>
<span class="normal">2374</span>
<span class="normal">2375</span>
<span class="normal">2376</span>
<span class="normal">2377</span>
<span class="normal">2378</span>
<span class="normal">2379</span>
<span class="normal">2380</span>
<span class="normal">2381</span>
<span class="normal">2382</span>
<span class="normal">2383</span>
<span class="normal">2384</span>
<span class="normal">2385</span>
<span class="normal">2386</span>
<span class="normal">2387</span>
<span class="normal">2388</span>
<span class="normal">2389</span>
<span class="normal">2390</span>
<span class="normal">2391</span>
<span class="normal">2392</span>
<span class="normal">2393</span>
<span class="normal">2394</span>
<span class="normal">2395</span>
<span class="normal">2396</span>
<span class="normal">2397</span>
<span class="normal">2398</span>
<span class="normal">2399</span>
<span class="normal">2400</span>
<span class="normal">2401</span>
<span class="normal">2402</span>
<span class="normal">2403</span>
<span class="normal">2404</span>
<span class="normal">2405</span>
<span class="normal">2406</span>
<span class="normal">2407</span>
<span class="normal">2408</span>
<span class="normal">2409</span>
<span class="normal">2410</span>
<span class="normal">2411</span>
<span class="normal">2412</span>
<span class="normal">2413</span>
<span class="normal">2414</span>
<span class="normal">2415</span>
<span class="normal">2416</span>
<span class="normal">2417</span>
<span class="normal">2418</span>
<span class="normal">2419</span>
<span class="normal">2420</span>
<span class="normal">2421</span>
<span class="normal">2422</span>
<span class="normal">2423</span>
<span class="normal">2424</span>
<span class="normal">2425</span>
<span class="normal">2426</span>
<span class="normal">2427</span>
<span class="normal">2428</span>
<span class="normal">2429</span>
<span class="normal">2430</span>
<span class="normal">2431</span>
<span class="normal">2432</span>
<span class="normal">2433</span>
<span class="normal">2434</span>
<span class="normal">2435</span>
<span class="normal">2436</span>
<span class="normal">2437</span>
<span class="normal">2438</span>
<span class="normal">2439</span>
<span class="normal">2440</span>
<span class="normal">2441</span>
<span class="normal">2442</span>
<span class="normal">2443</span>
<span class="normal">2444</span>
<span class="normal">2445</span>
<span class="normal">2446</span>
<span class="normal">2447</span>
<span class="normal">2448</span>
<span class="normal">2449</span>
<span class="normal">2450</span>
<span class="normal">2451</span>
<span class="normal">2452</span>
<span class="normal">2453</span>
<span class="normal">2454</span>
<span class="normal">2455</span>
<span class="normal">2456</span>
<span class="normal">2457</span>
<span class="normal">2458</span>
<span class="normal">2459</span>
<span class="normal">2460</span>
<span class="normal">2461</span>
<span class="normal">2462</span>
<span class="normal">2463</span>
<span class="normal">2464</span>
<span class="normal">2465</span>
<span class="normal">2466</span>
<span class="normal">2467</span>
<span class="normal">2468</span>
<span class="normal">2469</span>
<span class="normal">2470</span>
<span class="normal">2471</span>
<span class="normal">2472</span>
<span class="normal">2473</span>
<span class="normal">2474</span>
<span class="normal">2475</span>
<span class="normal">2476</span>
<span class="normal">2477</span>
<span class="normal">2478</span>
<span class="normal">2479</span>
<span class="normal">2480</span>
<span class="normal">2481</span>
<span class="normal">2482</span>
<span class="normal">2483</span>
<span class="normal">2484</span>
<span class="normal">2485</span>
<span class="normal">2486</span>
<span class="normal">2487</span>
<span class="normal">2488</span>
<span class="normal">2489</span>
<span class="normal">2490</span>
<span class="normal">2491</span>
<span class="normal">2492</span>
<span class="normal">2493</span>
<span class="normal">2494</span>
<span class="normal">2495</span>
<span class="normal">2496</span>
<span class="normal">2497</span>
<span class="normal">2498</span>
<span class="normal">2499</span>
<span class="normal">2500</span>
<span class="normal">2501</span>
<span class="normal">2502</span>
<span class="normal">2503</span>
<span class="normal">2504</span>
<span class="normal">2505</span>
<span class="normal">2506</span>
<span class="normal">2507</span>
<span class="normal">2508</span>
<span class="normal">2509</span>
<span class="normal">2510</span>
<span class="normal">2511</span>
<span class="normal">2512</span>
<span class="normal">2513</span>
<span class="normal">2514</span>
<span class="normal">2515</span>
<span class="normal">2516</span>
<span class="normal">2517</span>
<span class="normal">2518</span>
<span class="normal">2519</span>
<span class="normal">2520</span>
<span class="normal">2521</span>
<span class="normal">2522</span>
<span class="normal">2523</span>
<span class="normal">2524</span>
<span class="normal">2525</span>
<span class="normal">2526</span>
<span class="normal">2527</span>
<span class="normal">2528</span>
<span class="normal">2529</span>
<span class="normal">2530</span>
<span class="normal">2531</span>
<span class="normal">2532</span>
<span class="normal">2533</span>
<span class="normal">2534</span>
<span class="normal">2535</span>
<span class="normal">2536</span>
<span class="normal">2537</span>
<span class="normal">2538</span>
<span class="normal">2539</span>
<span class="normal">2540</span>
<span class="normal">2541</span>
<span class="normal">2542</span>
<span class="normal">2543</span>
<span class="normal">2544</span>
<span class="normal">2545</span>
<span class="normal">2546</span>
<span class="normal">2547</span>
<span class="normal">2548</span>
<span class="normal">2549</span>
<span class="normal">2550</span>
<span class="normal">2551</span>
<span class="normal">2552</span>
<span class="normal">2553</span>
<span class="normal">2554</span>
<span class="normal">2555</span>
<span class="normal">2556</span>
<span class="normal">2557</span>
<span class="normal">2558</span>
<span class="normal">2559</span>
<span class="normal">2560</span>
<span class="normal">2561</span>
<span class="normal">2562</span>
<span class="normal">2563</span>
<span class="normal">2564</span>
<span class="normal">2565</span>
<span class="normal">2566</span>
<span class="normal">2567</span>
<span class="normal">2568</span>
<span class="normal">2569</span>
<span class="normal">2570</span>
<span class="normal">2571</span>
<span class="normal">2572</span>
<span class="normal">2573</span>
<span class="normal">2574</span>
<span class="normal">2575</span>
<span class="normal">2576</span>
<span class="normal">2577</span>
<span class="normal">2578</span>
<span class="normal">2579</span>
<span class="normal">2580</span>
<span class="normal">2581</span>
<span class="normal">2582</span>
<span class="normal">2583</span>
<span class="normal">2584</span>
<span class="normal">2585</span>
<span class="normal">2586</span>
<span class="normal">2587</span>
<span class="normal">2588</span>
<span class="normal">2589</span>
<span class="normal">2590</span>
<span class="normal">2591</span>
<span class="normal">2592</span>
<span class="normal">2593</span>
<span class="normal">2594</span>
<span class="normal">2595</span>
<span class="normal">2596</span>
<span class="normal">2597</span>
<span class="normal">2598</span>
<span class="normal">2599</span>
<span class="normal">2600</span>
<span class="normal">2601</span>
<span class="normal">2602</span>
<span class="normal">2603</span>
<span class="normal">2604</span>
<span class="normal">2605</span>
<span class="normal">2606</span>
<span class="normal">2607</span>
<span class="normal">2608</span>
<span class="normal">2609</span>
<span class="normal">2610</span>
<span class="normal">2611</span>
<span class="normal">2612</span>
<span class="normal">2613</span>
<span class="normal">2614</span>
<span class="normal">2615</span>
<span class="normal">2616</span>
<span class="normal">2617</span>
<span class="normal">2618</span>
<span class="normal">2619</span>
<span class="normal">2620</span>
<span class="normal">2621</span>
<span class="normal">2622</span>
<span class="normal">2623</span>
<span class="normal">2624</span>
<span class="normal">2625</span>
<span class="normal">2626</span>
<span class="normal">2627</span>
<span class="normal">2628</span>
<span class="normal">2629</span>
<span class="normal">2630</span>
<span class="normal">2631</span>
<span class="normal">2632</span>
<span class="normal">2633</span>
<span class="normal">2634</span>
<span class="normal">2635</span>
<span class="normal">2636</span>
<span class="normal">2637</span>
<span class="normal">2638</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Module</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Module base class.</span>

<span class="sd">    Modules are everything that can be passed to `jx.integrate`, i.e. compartments,</span>
<span class="sd">    branches, cells, and networks.</span>

<span class="sd">    This base class defines the scaffold for all jaxley modules (compartments,</span>
<span class="sd">    branches, cells, networks).</span>

<span class="sd">    Modules can be traversed and modified using the `at`, `cell`, `branch`, `comp`,</span>
<span class="sd">    `edge`, and `loc` methods. The `scope` method can be used to toggle between</span>
<span class="sd">    global and local indices. Traversal of Modules will return a `View` of itself,</span>
<span class="sd">    that has a modified set of attributes, which only consider the part of the Module</span>
<span class="sd">    that is in view.</span>

<span class="sd">    For developers: The above has consequences for how to operate on `Module` and which</span>
<span class="sd">    changes take affect where. The following guidelines should be followed (copied from</span>
<span class="sd">    `View`):</span>

<span class="sd">    1. We consider a Module to have everything in view.</span>
<span class="sd">    2. Views can display and keep track of how a module is traversed. But(!),</span>
<span class="sd">       do not support making changes or setting variables. This still has to be</span>
<span class="sd">       done in the base Module, i.e. `self.base`. In order to enssure that these</span>
<span class="sd">       changes only affects whatever is currently in view `self._nodes_in_view`,</span>
<span class="sd">       or `self._edges_in_view` among others have to be used. Operating on nodes</span>
<span class="sd">       currently in view can for example be done with</span>
<span class="sd">       `self.base.node.loc[self._nodes_in_view]`.</span>
<span class="sd">    3. Every attribute of Module that changes based on what&#39;s in view, i.e. `xyzr`,</span>
<span class="sd">       needs to modified when View is instantiated. I.e. `xyzr` of `cell.branch(0)`,</span>
<span class="sd">       should be `[self.base.xyzr[0]]` This could be achieved via:</span>
<span class="sd">       `[self.base.xyzr[b] for b in self._branches_in_view]`.</span>

<span class="sd">    For developers: If you want to add a new method to `Module`, here is an example of</span>
<span class="sd">    how to make methods of Module compatible with View:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Use data in view to return something.</span>
<span class="sd">        def count_small_branches(self):</span>
<span class="sd">            # no need to use self.base.attr + viewed indices,</span>
<span class="sd">            # since no change is made to the attr in question (nodes)</span>
<span class="sd">            comp_lens = self.nodes[&quot;length&quot;]</span>
<span class="sd">            branch_lens = comp_lens.groupby(&quot;global_branch_index&quot;).sum()</span>
<span class="sd">            return np.sum(branch_lens &lt; 10)</span>

<span class="sd">        # Change data in view.</span>
<span class="sd">        def change_attr_in_view(self):</span>
<span class="sd">            # changes to attrs have to be made via self.base.attr + viewed indices</span>
<span class="sd">            a = func1(self.base.attr1[self._cells_in_view])</span>
<span class="sd">            b = func2(self.base.attr2[self._edges_in_view])</span>
<span class="sd">            self.base.attr3[self._branches_in_view] = a + b</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span>  <span class="c1"># defaults to local scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;global_edge_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;pre_global_comp_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;post_global_comp_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;pre_locs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;post_locs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type_ind&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_syns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># List of all types of `jx.Synapse`s.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_current_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># List of types of all `jx.Channel`s.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># List of all pumps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Pump</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># List of all states (exluding voltage) that are being diffused.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For trainable parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_make_trainable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># For recordings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recordings</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>

        <span class="c1"># For stimuli or clamps.</span>
        <span class="c1"># E.g. `self.externals = {&quot;v&quot;: zeros(1000,2), &quot;i&quot;: ones(1000, 2)}`</span>
        <span class="c1"># for 1000 timesteps and two compartments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># E.g. `self.external)inds = {&quot;v&quot;: jnp.asarray([0,1]), &quot;i&quot;: jnp.asarray([2,3])}`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># x, y, z coordinates and radius.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius_generating_fns</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Defined by `.read_swc()`.</span>

        <span class="c1"># For debugging the solver. Will be empty by default and only filled if</span>
        <span class="c1"># `self._init_morph_for_debugging` is run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># needs to be set at the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span> <span class="n">Module</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="si">}</span><span class="s2"> different channels. Use `.nodes` for details.&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;jx.</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base_dir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># Ensure that hidden methods such as `__deepcopy__` still work.</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># intercepts calls to groups</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">view</span>

        <span class="c1"># intercepts calls to channels</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]:</span>
            <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel_names</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">view</span>

        <span class="c1"># intercepts calls to synapse types</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_names</span><span class="p">:</span>
            <span class="n">syn_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">][</span>
                <span class="s2">&quot;global_edge_index&quot;</span>
            <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">orig_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span>
            <span class="n">view</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">syn_inds</span><span class="p">)</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="n">orig_scope</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># overwrites param set by edge</span>
            <span class="c1"># Ensure synapse param sharing works with `edge`</span>
            <span class="c1"># `edge` will be removed as part of #463</span>
            <span class="n">view</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;local_edge_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_childviews</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns levels that module can be viewed at.</span>

<span class="sd">        I.e. for net -&gt; [cell, branch, comp]. For branch -&gt; [comp]&quot;&quot;&quot;</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="n">levels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">children</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_has_childview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">child_views</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childviews</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">child_views</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lazy indexing of the module.&quot;&quot;&quot;</span>
        <span class="n">supported_parents</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;branch&quot;</span><span class="p">]</span>  <span class="c1"># cannot index into comp</span>

        <span class="n">not_group_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="ow">in</span> <span class="n">supported_parents</span> <span class="ow">or</span> <span class="n">not_group_view</span>
        <span class="p">),</span> <span class="s2">&quot;Lazy indexing is only supported for `Network`, `Cell`, `Branch` and Views thereof.&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>

        <span class="n">child_views</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childviews</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_views</span><span class="p">),</span> <span class="s2">&quot;Too many indices.&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child_views</span><span class="p">):</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_local_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute local indices from the global indices that are in view.</span>
<span class="sd">        This is recomputed everytime a View is created.&quot;&quot;&quot;</span>
        <span class="n">rerank</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">reorder_cols</span><span class="p">(</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Move cols to front/back.</span>

<span class="sd">            Args:</span>
<span class="sd">                df: DataFrame to reorder.</span>
<span class="sd">                cols: List of columns to place before/after remaining columns.</span>
<span class="sd">                first: If True, cols are placed in front, otherwise at the end.</span>

<span class="sd">            Returns:</span>
<span class="sd">                DataFrame with reordered columns.&quot;&quot;&quot;</span>
            <span class="n">new_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">)]</span>
            <span class="n">new_cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">first</span> <span class="o">!=</span> <span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">new_cols</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">reindex_a_by_b</span><span class="p">(</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Reindex based on a different col or several columns</span>
<span class="sd">            for b=[0,0,1,1,2,2,2] -&gt; a=[0,1,0,1,0,1,2]&quot;&quot;&quot;</span>
            <span class="n">grouped_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">df</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">rerank</span><span class="p">(</span><span class="n">grouped_df</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">df</span>

        <span class="n">index_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">,</span> <span class="s2">&quot;branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>  <span class="c1"># order is important</span>
        <span class="n">global_idx_cols</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;global_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_names</span><span class="p">]</span>
        <span class="n">local_idx_cols</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;local_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_names</span><span class="p">]</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">global_idx_cols</span><span class="p">]</span>

        <span class="c1"># update local indices of nodes</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="n">reindex_a_by_b</span><span class="p">(</span><span class="n">idcs</span><span class="p">,</span> <span class="n">global_idx_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="n">reindex_a_by_b</span><span class="p">(</span><span class="n">idcs</span><span class="p">,</span> <span class="n">global_idx_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">global_idx_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="n">reindex_a_by_b</span><span class="p">(</span><span class="n">idcs</span><span class="p">,</span> <span class="n">global_idx_cols</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">global_idx_cols</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">idcs</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="s2">&quot;local&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">global_idx_cols</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">local_idx_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">idcs</span><span class="p">[</span><span class="n">local_idx_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># move indices to the front of the dataframe; move controlled_by_param to the end</span>
        <span class="c1"># move indices of current scope to the front and the others to the back</span>
        <span class="n">not_scope</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">==</span> <span class="s2">&quot;local&quot;</span> <span class="k">else</span> <span class="s2">&quot;local&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">reorder_cols</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_names</span><span class="p">],</span> <span class="n">first</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">reorder_cols</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">not_scope</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">index_names</span><span class="p">],</span> <span class="n">first</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">reorder_cols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;global_edge_index&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">reorder_cols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">],</span> <span class="n">first</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">reorder_cols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">],</span> <span class="n">first</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Init attributes critical for View.</span>

<span class="sd">        Needs to be called at init of a Module.&quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">=</span> <span class="s2">&quot;comp&quot;</span> <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="s2">&quot;compartment&quot;</span> <span class="k">else</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_coords_of_comp_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute xyz coordinates of compartment centers.</span>

<span class="sd">        Centers are the midpoint between the comparment endpoints on the morphology</span>
<span class="sd">        as defined by xyzr.</span>

<span class="sd">        Note: For sake of performance, interpolation is not done for each branch</span>
<span class="sd">        individually, but only once along a concatenated (and padded) array of all branches.</span>
<span class="sd">        This means for ncomps = [2,4] and normalized cum_branch_lens of [[0,1],[0,1]] we would</span>
<span class="sd">        interpolate xyz at the locations comp_ends = [[0,0.5,1], [0,0.25,0.5,0.75,1]],</span>
<span class="sd">        where 0 is the start of the branch and 1 is the end point at the full branch_len.</span>
<span class="sd">        To avoid do this in one go we set comp_ends = [0,0.5,1,2,2.25,2.5,2.75,3], and</span>
<span class="sd">        norm_cum_branch_len = [0,1,2,3] incrememting and also padding them by 1 to</span>
<span class="sd">        avoid overlapping branch_lens i.e. norm_cum_branch_len = [0,1,1,2] for only</span>
<span class="sd">        incrementing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes_by_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">)</span>
        <span class="n">ncomps</span> <span class="o">=</span> <span class="n">nodes_by_branches</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">comp_ends</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ncomp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ncomps</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">comp_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">comp_ends</span><span class="p">)</span>

        <span class="n">comp_ends</span> <span class="o">=</span> <span class="n">comp_ends</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cum_branch_lens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xyzr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">):</span>
            <span class="n">branch_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xyzr</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">cum_branch_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">branch_len</span><span class="p">]))</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="n">cum_branch_len</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="c1"># add padding like above</span>
            <span class="n">cum_branch_len</span> <span class="o">=</span> <span class="n">cum_branch_len</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_len</span> <span class="k">if</span> <span class="n">max_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
            <span class="n">cum_branch_len</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cum_branch_len</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cum_branch_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cum_branch_len</span><span class="p">)</span>
        <span class="n">cum_branch_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">cum_branch_lens</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">v_interp</span><span class="p">(</span><span class="n">comp_ends</span><span class="p">,</span> <span class="n">cum_branch_lens</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># unaware of inter vs intra comp centers</span>
        <span class="n">cum_ncomps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ncomps</span><span class="p">)</span>
        <span class="c1"># this means centers between comps have to be removed here</span>
        <span class="n">between_comp_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">cum_ncomps</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cum_ncomps</span><span class="p">)))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">between_comp_inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">centers</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute_compartment_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add compartment centers to nodes dataframe&quot;&quot;&quot;</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_coords_of_comp_centers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">centers</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reformat_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transforms different types of indices into an array.</span>

<span class="sd">        Takes slice, list, array, ints, range and None and transforms</span>
<span class="sd">        it into array of indices. If index == &quot;all&quot; it returns &quot;all&quot;</span>
<span class="sd">        to be handled downstream.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index that specifies at which locations to view the module.</span>
<span class="sd">            dtype: defaults to int, but can also reformat float for use in `loc`</span>

<span class="sd">        Returns:</span>
<span class="sd">            array of indices of shape (N,)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>  <span class="c1"># also asserts that the only allowed str == &quot;all&quot;</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">type</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">idx</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np_dtype</span><span class="p">))</span> <span class="k">else</span> <span class="n">idx</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">))</span> <span class="k">else</span> <span class="n">idx</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">))[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="n">idx</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
            <span class="n">which_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">which_idx</span><span class="p">),</span> <span class="s2">&quot;Index not matching num of cells/branches/comps.&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">which_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>

            <span class="c1"># Typically, `select` is run on `Module`, not on `View`. In these cases,</span>
            <span class="c1"># `nodes` will exactly the index of the `index` of the `self.nodes`</span>
            <span class="c1"># dataframe, and the line below is not needed. But if one wants to call</span>
            <span class="c1"># select multiple times in a chained way (e.g. when having multiple groups</span>
            <span class="c1"># and wanting to get their intersection, e.g., `net.exc.fast_spiking` or</span>
            <span class="c1"># `net.exc.soma`), the global index traced in `self.nodes.index` does no</span>
            <span class="c1"># longer match `nodes`. The line below translates the local index of</span>
            <span class="c1"># `nodes` to the global `self.nodes.index`.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;Invalid type&quot;</span>
        <span class="k">assert</span> <span class="n">idx</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">np_dtype</span><span class="p">,</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Invalid dtype, found </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead of </span><span class="si">{</span><span class="nb">str</span><span class="p">([</span><span class="n">np_dtype</span><span class="p">,</span><span class="w"> </span><span class="nb">bool</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">idx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_controlled_by_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determines which parameters are shared in `make_trainable`.</span>

<span class="sd">        Adds column to nodes/edges dataframes to read of shared params from.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: key specifying group / view that is in control of the params.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;comp&quot;</span><span class="p">,</span> <span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;global_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_index&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;filter&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">=</span> <span class="n">key</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return View of the module filtered by specific node or edges indices.</span>

<span class="sd">        The selection is made based on the `index` of the `self.nodes` or `self.edges`,</span>
<span class="sd">        i.e., not on a local compartment index or a local row number (`loc`, not</span>
<span class="sd">        `iloc`).</span>

<span class="sd">        Args:</span>
<span class="sd">            nodes: indices of nodes to view. If None, all nodes are viewed.</span>
<span class="sd">            edges: indices of edges to view. If None, all edges are viewed.</span>
<span class="sd">            sorted: if True, nodes and edges are sorted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View for subset of selected nodes and/or edges.&quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">else</span> <span class="n">nodes</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sorted</span> <span class="k">else</span> <span class="n">nodes</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">else</span> <span class="n">edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sorted</span> <span class="k">else</span> <span class="n">edges</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Toggle between &quot;global&quot; or &quot;local&quot; scope.</span>

<span class="sd">        Determines if global or local indices are used for viewing the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            scope: either &quot;global&quot; or &quot;local&quot;.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">scope</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="s2">&quot;local&quot;</span><span class="p">],</span> <span class="s2">&quot;Invalid scope.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">=</span> <span class="n">scope</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module with the specified scope.</span>

<span class="sd">        For example `cell.scope(&quot;global&quot;).branch(2).scope(&quot;local&quot;).comp(1)`</span>
<span class="sd">        will return the 1st compartment of branch 2.</span>

<span class="sd">        Args:</span>
<span class="sd">            scope: either &quot;global&quot; or &quot;local&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View with the specified scope.&quot;&quot;&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span>
        <span class="n">view</span><span class="o">.</span><span class="n">set_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_at_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module filtering `nodes` by specified key and index.</span>

<span class="sd">        Keys can be `cell`, `branch`, `comp` and determine which index is used to filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_has_childview</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_name</span><span class="si">}</span><span class="s2"> does not support </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_index&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">else</span> <span class="n">idx</span>
        <span class="n">where</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">where</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">inds</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_at_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module filtering `edges` by specified key and index.</span>

<span class="sd">        Keys can be `pre`, `post`, `edge` and determine which index is used to filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_index&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">else</span> <span class="n">idx</span>
        <span class="n">where</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">where</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">inds</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected cell(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index of the cell to view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View of the module at the specified cell index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected branches(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index of the branch to view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View of the module at the specified branch index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected compartments(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index of the comp to view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View of the module at the specified compartment index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="s2">&quot;comp&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected synapse edges(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index of the edge to view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View of the module at the specified edge index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_edges</span><span class="p">(</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected branch location(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            at: location along the branch.</span>

<span class="sd">        Returns:</span>
<span class="sd">            View of the module at the specified branch location.&quot;&quot;&quot;</span>
        <span class="n">global_comp_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
            <span class="n">ncomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">comp_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">)</span>
            <span class="n">at</span> <span class="o">=</span> <span class="n">comp_locs</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">comp_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">comp_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">global_comp_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">global_comp_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">global_comp_idxs</span><span class="p">)</span>
        <span class="n">orig_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span>
        <span class="c1"># global scope needed to select correct comps, for i.e. branches w. ncomp=[1,2]</span>
        <span class="c1"># loc(0.9)  will correspond to different local branches (0 vs 1).</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">comp</span><span class="p">(</span><span class="n">global_comp_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="n">orig_scope</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">=</span> <span class="s2">&quot;loc&quot;</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_comps_in_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lists the global compartment indices which are currently part of the view.&quot;&quot;&quot;</span>
        <span class="c1"># method also exists in View. this copy forgoes need to instantiate a View</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_branches_in_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lists the global branch indices which are currently part of the view.&quot;&quot;&quot;</span>
        <span class="c1"># method also exists in View. this copy forgoes need to instantiate a View</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_cells_in_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lists the global cell indices which are currently part of the view.&quot;&quot;&quot;</span>
        <span class="c1"># method also exists in View. this copy forgoes need to instantiate a View</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_iter_submodules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over submoduleslevel.</span>

<span class="sd">        Used for `cells`, `branches`, `comps`.&quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_index&quot;</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all cells in the module.</span>

<span class="sd">        Returns a generator that yields a View of each cell.&quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_submodules</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all branches in the module.</span>

<span class="sd">        Returns a generator that yields a View of each branch.&quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_submodules</span><span class="p">(</span><span class="s2">&quot;branch&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">comps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all compartments in the module.</span>
<span class="sd">        Can be called on any module, i.e. `net.comps`, `cell.comps` or</span>
<span class="sd">        `branch.comps`. `__iter__` does not allow for this.</span>

<span class="sd">        Returns a generator that yields a View of each compartment.&quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_submodules</span><span class="p">(</span><span class="s2">&quot;comp&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over parts of the module.</span>

<span class="sd">        Internally calls `cells`, `branches`, `comps` at the appropriate level.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            for cell in network:</span>
<span class="sd">                for branch in cell:</span>
<span class="sd">                    for comp in branch:</span>
<span class="sd">                        print(comp.nodes.shape)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childviews</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_submodules</span><span class="p">(</span><span class="n">next_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of submodules contained in a module.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            network.shape = (num_cells, num_branches, num_compartments)</span>
<span class="sd">            cell.shape = (num_branches, num_compartments)</span>
<span class="sd">            branch.shape = (num_compartments,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">,</span> <span class="s2">&quot;global_branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span>
        <span class="n">raw_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

        <span class="c1"># ensure (net.shape -&gt; dim=3, cell.shape -&gt; dim=2, branch.shape -&gt; dim=1, comp.shape -&gt; dim=0)</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="s2">&quot;comp&quot;</span><span class="p">]</span>
        <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">module</span> <span class="o">=</span> <span class="s2">&quot;comp&quot;</span> <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;compartment&quot;</span> <span class="k">else</span> <span class="n">module</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">raw_shape</span><span class="p">[</span><span class="n">levels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="n">shape</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reset_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">as_module</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Module</span><span class="p">,</span> <span class="n">View</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract part of a module and return a copy of its View or a new module.</span>

<span class="sd">        This can be used to call `jx.integrate` on part of a Module.</span>

<span class="sd">        Args:</span>
<span class="sd">            reset_index: if True, the indices of the new module are reset to start from 0.</span>
<span class="sd">            as_module: if True, a new module is returned instead of a View.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A part of the module or a copied view of it.&quot;&quot;&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This method is experimental, use at your own risk.&quot;</span><span class="p">)</span>
        <span class="c1"># TODO FROM #447: add reset_index, i.e. for parents, nodes, edges etc. such that they</span>
        <span class="c1"># start from 0/-1 and are contiguous</span>
        <span class="k">if</span> <span class="n">as_module</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not yet implemented.&quot;</span><span class="p">)</span>
            <span class="c1"># initialize a new module with the same attributes</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return view of the module.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">View</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_module_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return type of the module (compartment, branch, cell, network) as string.</span>

<span class="sd">        This is used to perform asserts for some modules (e.g. network cannot use</span>
<span class="sd">        `set_ncomp`) without having to import the module in `base.py`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert the default params of the module (e.g. radius, length).</span>

<span class="sd">        This is run at `__init__()`. It does not deal with channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_value</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_value</span>
        <span class="k">for</span> <span class="n">state_name</span><span class="p">,</span> <span class="n">state_value</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_gather_channels_from_constituents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify `self.channels` and `self.nodes` with channel info from constituents.</span>

<span class="sd">        This is run at `__init__()`. It takes all branches of constituents (e.g.</span>
<span class="sd">        of all branches when the are assembled into a cell) and adds columns to</span>
<span class="sd">        `.nodes` for the relevant channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">constituents</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot have diffusion in subparts of a module. As a workaround, set &quot;</span>
                <span class="s2">&quot;the diffusion constant for all parts that should not have ion &quot;</span>
                <span class="s2">&quot;diffusion to a very small value (e.g. 1e-8).&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pump</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pump</span><span class="o">.</span><span class="n">_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pump</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pump</span><span class="o">.</span><span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pump</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="c1"># Setting columns of channel and pump names to `False` instead of `NaN`.</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_jax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO FROM #447: Make this work for View?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move `.nodes` to `.jaxnodes`.</span>

<span class="sd">        Before the actual simulation is run (via `jx.integrate`), all parameters of</span>
<span class="sd">        the `jx.Module` are stored in `.nodes` (a `pd.DataFrame`). However, for</span>
<span class="sd">        simulation, these parameters have to be moved to be `jnp.ndarrays` such that</span>
<span class="sd">        they can be processed on GPU/TPU and such that the simulation can be</span>
<span class="sd">        differentiated. `.to_jax()` copies the `.nodes` to `.jaxnodes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="n">inds</span><span class="p">]</span>

        <span class="c1"># `jaxedges` contains only parameters (no indices).</span>
        <span class="c1"># `jaxedges` contains only non-Nan elements. This is unlike the channels where</span>
        <span class="c1"># we allow parameter sharing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_params</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_states</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">show</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print detailed information about the Module or a view of it.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_names: The names of the parameters to show. If `None`, all parameters</span>
<span class="sd">                are shown.</span>
<span class="sd">            indices: Whether to show the indices of the compartments.</span>
<span class="sd">            params: Whether to show the parameters of the compartments.</span>
<span class="sd">            states: Whether to show the states of the compartments.</span>
<span class="sd">            channel_names: The names of the channels to show. If `None`, all channels are</span>
<span class="sd">                shown.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `pd.DataFrame` with the requested information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># prevents this from being edited</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">,</span> <span class="s2">&quot;branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
        <span class="n">scopes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;local&quot;</span><span class="p">,</span> <span class="s2">&quot;global&quot;</span><span class="p">]</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scopes</span><span class="p">]</span> <span class="k">if</span> <span class="n">indices</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">+=</span> <span class="n">inds</span>
        <span class="n">cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span> <span class="k">if</span> <span class="n">channel_names</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">channel_params</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">],</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="n">cols</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">channel_states</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">],</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">states</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">inds</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">params</span>
                <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">nodes</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the morphology such that it can be processed by the solvers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_morph_jaxley_spsolve</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_morph_jax_spsolve</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jax_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the morphology for the JAX sparse solver.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jaxley_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the morphology for the custom Jaxley solver.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_axial_conductances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given radius, length, r_a, compute the axial coupling conductances.</span>

<span class="sd">        If ion diffusion was activated by the user (with `cell.diffuse()`) then this</span>
<span class="sd">        function also compute the axial conductances for every ion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">compute_axial_conductances</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value.</span>

<span class="sd">        Note that this function can not be called within `jax.jit` or `jax.grad`.</span>
<span class="sd">        Instead, it should be used set the parameters of the module **before** the</span>
<span class="sd">        simulation. Use `.data_set()` to set parameters during `jax.jit` or</span>
<span class="sd">        `jax.grad`.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The name of the parameter to set.</span>
<span class="sd">            val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">                must be of shape `(len(num_compartments))`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">ion_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You are trying to set `</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">` to `</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">`. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;We only allow strictly positive values for the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;diffusion. Zero is not allowed either, but you can use very small &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;values (e.g. 1e-8).&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">[</span><span class="n">not_nan</span><span class="p">],</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span><span class="p">[</span><span class="n">not_nan</span><span class="p">],</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in nodes or edges&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">data_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">param_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value within `jit`.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The name of the parameter to set.</span>
<span class="sd">            val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">                must be of shape `(len(num_compartments))`.</span>
<span class="sd">            param_state: State of the setted parameters, internally used such that this</span>
<span class="sd">                function does not modify global state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: `data_set` does not support arrays for `val`.</span>
        <span class="n">is_node_param</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">is_node_param</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="n">viewed_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span> <span class="k">if</span> <span class="n">is_node_param</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
            <span class="n">added_param_state</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;indices&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">viewed_inds</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]),</span>
                    <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
                    <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)),</span>
                <span class="p">}</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">param_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param_state</span> <span class="o">+=</span> <span class="n">added_param_state</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param_state</span> <span class="o">=</span> <span class="n">added_param_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Key not recognized.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">param_state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_ncomp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ncomp</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">min_radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the number of compartments with which the branch is discretized.</span>

<span class="sd">        Args:</span>
<span class="sd">            ncomp: The number of compartments that the branch should be discretized</span>
<span class="sd">                into.</span>
<span class="sd">            min_radius: Only used if the morphology was read from an SWC file. If passed</span>
<span class="sd">                the radius is capped to be at least this value.</span>

<span class="sd">        Raises:</span>
<span class="sd">            - When there are stimuli in any compartment in the module.</span>
<span class="sd">            - When there are recordings in any compartment in the module.</span>
<span class="sd">            - When the channels of the compartments are not the same within the branch</span>
<span class="sd">            that is modified.</span>
<span class="sd">            - When the lengths of the compartments are not the same within the branch</span>
<span class="sd">            that is modified.</span>
<span class="sd">            - When the branch that is modified has compartments belonging to different</span>
<span class="sd">            groups.</span>
<span class="sd">            - Unless the morphology was read from an SWC file, when the radiuses of the</span>
<span class="sd">            compartments are not the same within the branch that is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No stimuli allowed!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No recordings allowed!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No trainables allowed!&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_module_type</span> <span class="o">!=</span> <span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;This is not allowed for networks.&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_module_type</span> <span class="o">==</span> <span class="s2">&quot;cell&quot;</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;This is not allowed for cells.&quot;</span>

        <span class="c1"># Update all attributes that are affected by compartment structure.</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp_per_branch</span>
        <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
        <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">channel_params</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">channel_states</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">radius_generating_fns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_radius_generating_fns</span>

        <span class="n">within_branch_radiuses</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">compartment_lengths</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">num_previous_ncomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">within_branch_radiuses</span><span class="p">)</span>
        <span class="n">branch_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">])</span>

        <span class="n">error_msg</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You previously modified the </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> of individual compartments, but &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;now you are modifying the number of compartments in this branch. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;This is not allowed. First build the morphology with `set_ncomp()` and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;then modify the radiuses and lengths of compartments.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">within_branch_radiuses</span> <span class="o">==</span> <span class="n">within_branch_radiuses</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">radius_generating_fns</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;capacitance&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">]:</span>
            <span class="n">compartment_properties</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">compartment_properties</span> <span class="o">==</span> <span class="n">compartment_properties</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">(</span><span class="n">property_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">channel_names</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Some channel exists only in some compartments of the branch which you&quot;</span>
                <span class="s2">&quot;are trying to modify. This is not allowed. First specify the number&quot;</span>
                <span class="s2">&quot;of compartments with `.set_ncomp()` and then insert the channels&quot;</span>
                <span class="s2">&quot;accordingly.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">channel_param_names</span> <span class="o">+</span> <span class="n">channel_state_names</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span>
        <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Some channel has different parameters or states between the &quot;</span>
                <span class="s2">&quot;different compartments of the branch which you are trying to modify. &quot;</span>
                <span class="s2">&quot;This is not allowed. First specify the number of compartments with &quot;</span>
                <span class="s2">&quot;`.set_ncomp()` and then insert the channels accordingly.&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
            <span class="n">group_ncomp</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">group_ncomp</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">group_ncomp</span> <span class="o">==</span> <span class="n">num_previous_ncomp</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_ncomp</span><span class="si">}</span><span class="s2"> compartments within the branch are part of the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;group &#39;</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s2">&#39;, but the other &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_previous_ncomp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">group_ncomp</span><span class="si">}</span><span class="s2"> compartments are not. This &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;is not allowed: Every compartment must belong to the same group for &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`.set_ncomp()` to work.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Add new rows as the average of all rows. Special case for the length is below.</span>
        <span class="n">average_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">average_row</span> <span class="o">=</span> <span class="n">average_row</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="o">*</span><span class="p">[</span><span class="n">average_row</span><span class="p">]</span> <span class="o">*</span> <span class="n">ncomp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">)</span>

        <span class="c1"># Set the correct datatype after having performed an average which cast</span>
        <span class="c1"># everything to float.</span>
        <span class="n">integer_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">,</span> <span class="s2">&quot;global_branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span>
        <span class="n">view</span><span class="p">[</span><span class="n">integer_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">integer_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Whether or not a channel or group exists in a compartment is a boolean.</span>
        <span class="n">boolean_cols</span> <span class="o">=</span> <span class="n">channel_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span>
        <span class="n">view</span><span class="p">[</span><span class="n">boolean_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">boolean_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Special treatment for the lengths and radiuses. These are not being set as</span>
        <span class="c1"># the average because we:</span>
        <span class="c1"># 1) Want to maintain the total length of a branch.</span>
        <span class="c1"># 2) Want to use the SWC inferred radius.</span>
        <span class="c1">#</span>
        <span class="c1"># Compute new compartment lengths.</span>
        <span class="n">comp_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">compartment_lengths</span><span class="p">)</span> <span class="o">/</span> <span class="n">ncomp</span>
        <span class="n">view</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_lengths</span>

        <span class="c1"># Compute new compartment radiuses.</span>
        <span class="k">if</span> <span class="n">radius_generating_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">build_radiuses_from_xyzr</span><span class="p">(</span>
                <span class="n">radius_fns</span><span class="o">=</span><span class="n">radius_generating_fns</span><span class="p">,</span>
                <span class="n">branch_indices</span><span class="o">=</span><span class="n">branch_indices</span><span class="p">,</span>
                <span class="n">min_radius</span><span class="o">=</span><span class="n">min_radius</span><span class="p">,</span>
                <span class="n">ncomp</span><span class="o">=</span><span class="n">ncomp</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">within_branch_radiuses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span>

        <span class="c1"># Update `.nodes`.</span>
        <span class="c1"># 1) Delete N rows starting from start_idx</span>
        <span class="n">number_deleted</span> <span class="o">=</span> <span class="n">num_previous_ncomp</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">number_deleted</span><span class="p">))</span>

        <span class="c1"># 2) Insert M new rows at the same location</span>
        <span class="n">df1</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">start_idx</span><span class="p">]</span>  <span class="c1"># Rows before the insertion point</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:]</span>  <span class="c1"># Rows after the insertion point</span>

        <span class="c1"># 3) Combine the parts: before, new rows, and after</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df1</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">df2</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Override `comp_index` to just be a consecutive list.</span>
        <span class="n">all_nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">))</span>

        <span class="c1"># Update compartment structure arguments.</span>
        <span class="n">ncomp_per_branch</span><span class="p">[</span><span class="n">branch_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncomp</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ncomp_per_branch</span><span class="p">))</span>
        <span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="n">ncomp_per_branch</span><span class="p">)</span>
        <span class="n">internal_node_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">all_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">ncomp_per_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="n">ncomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_ncomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">internal_node_inds</span>

        <span class="c1"># Update the morphology indexing (e.g., `.comp_edges`).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">make_trainable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a parameter trainable.</span>

<span class="sd">        If a parameter is made trainable, it will be returned by `get_parameters()`</span>
<span class="sd">        and should then be passed to `jx.integrate(..., params=params)`.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: Name of the parameter to make trainable.</span>
<span class="sd">            init_val: Initial value of the parameter. If `float`, the same value is</span>
<span class="sd">                used for every created parameter. If `list`, the length of the list has</span>
<span class="sd">                to match the number of created parameters. If `None`, the current</span>
<span class="sd">                parameter value is used and if parameter sharing is performed that the</span>
<span class="sd">                current parameter value is averaged over all shared parameters.</span>
<span class="sd">            verbose: Whether to print the number of parameters that are added and the</span>
<span class="sd">                total number of parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allow_make_trainable</span>
        <span class="p">),</span> <span class="s2">&quot;network.cell(&#39;all&#39;).make_trainable() is not supported. Use a for-loop over cells.&quot;</span>
        <span class="n">ncomps_per_branch</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">data</span>

        <span class="k">assert</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in nodes or edges&quot;</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;No settable parameters found in the selected compartments.&quot;</span>

        <span class="n">grouped_view</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">)</span>
        <span class="c1"># Because of this `x.index.values` we cannot support `make_trainable()` on</span>
        <span class="c1"># the module level for synapse parameters (but only for `SynapseView`).</span>
        <span class="n">comp_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">grouped_view</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">include_groups</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># check if all shapes in comp_inds are the same. If not the case this means</span>
        <span class="c1"># the groups in controlled_by_param have different sizes, i.e. due to different</span>
        <span class="c1"># number of comps for two different branches. In this case we pad the smaller</span>
        <span class="c1"># groups with -1 to make them the same size.</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">])</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">constant_values</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">lens</span> <span class="o">==</span> <span class="n">max_len</span><span class="p">):</span>
            <span class="n">comp_inds</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pad</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">if</span> <span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_len</span> <span class="k">else</span> <span class="n">inds</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">comp_inds</span>
            <span class="p">]</span>

        <span class="c1"># Sorted inds are only used to infer the correct starting values.</span>
        <span class="n">indices_per_param</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">comp_inds</span><span class="p">)</span>

        <span class="c1"># Assign dummy param (ignored by nanmean later). This adds a new row to the</span>
        <span class="c1"># `data` (which is, e.g., self.nodes). That new row has index `-1`, which does</span>
        <span class="c1"># not clash with any other node index (they are in</span>
        <span class="c1"># `[0, ..., num_total_comps-1]`).</span>
        <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">param_vals</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">])</span>

        <span class="c1"># Set the value which the trainable parameter should take.</span>
        <span class="n">num_created_parameters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_per_param</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">init_val</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_created_parameters</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_created_parameters</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;len(init_val)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span><span class="si">}</span><span class="s2">, but trying to create </span><span class="si">{</span><span class="n">num_created_parameters</span><span class="si">}</span><span class="s2"> parameters.&quot;</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;init_val must a float, list, or None, but it is a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">param_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">new_params</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices_per_param</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">+=</span> <span class="n">num_created_parameters</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of newly added trainable parameters: </span><span class="si">{</span><span class="n">num_created_parameters</span><span class="si">}</span><span class="s2">. Total number of trainable parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_trainables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trainable_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the trainables into `.nodes` and `.edges`.</span>

<span class="sd">        This allows to, e.g., visualize trained networks with `.vis()`.</span>

<span class="sd">        Args:</span>
<span class="sd">            trainable_params: The trainable parameters returned by `get_parameters()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We do not support views. Why? `jaxedges` does not have any NaN</span>
        <span class="c1"># elements, whereas edges does. Because of this, we already need special</span>
        <span class="c1"># treatment to make this function work, and it would be an even bigger hassle</span>
        <span class="c1"># if we wanted to support this.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;Compartment&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Branch&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Cell&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Network&quot;</span><span class="p">,</span>
        <span class="p">],</span> <span class="s2">&quot;Only supports modules.&quot;</span>

        <span class="c1"># We could also implement this without casting the module to jax.</span>
        <span class="c1"># However, I think it allows us to reuse as much code as possible and it avoids</span>
        <span class="c1"># any kind of issues with indexing or parameter sharing (as this is fully</span>
        <span class="c1"># taken care of by `get_all_parameters()`).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">to_jax</span><span class="p">()</span>
        <span class="n">pstate</span> <span class="o">=</span> <span class="n">params_to_pstate</span><span class="p">(</span><span class="n">trainable_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="p">)</span>
        <span class="n">all_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_all_parameters</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">voltage_solver</span><span class="o">=</span><span class="s2">&quot;jaxley.stone&quot;</span><span class="p">)</span>

        <span class="c1"># The value for `delta_t` does not matter here because it is only used to</span>
        <span class="c1"># compute the initial current. However, the initial current cannot be made</span>
        <span class="c1"># trainable and so its value never gets used below.</span>
        <span class="n">all_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_all_states</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="mf">0.025</span><span class="p">)</span>

        <span class="c1"># Loop only over the keys in `pstate` to avoid unnecessary computation.</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">vals_to_set</span> <span class="o">=</span> <span class="n">all_params</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">all_states</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals_to_set</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># `jaxedges` contains only non-Nan elements. This is unlike the channels where</span>
        <span class="c1"># we allow parameter sharing.</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="s2">&quot;View&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the direct distance between two compartments.</span>
<span class="sd">        This does not compute the pathwise distance (which is currently not</span>
<span class="sd">        implemented).</span>
<span class="sd">        Args:</span>
<span class="sd">            endpoint: The compartment to which to compute the distance to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">start_xyz</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">end_xyz</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">start_xyz</span> <span class="o">-</span> <span class="n">end_xyz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">delete_trainables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all trainable parameters from the module.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">View</span><span class="p">):</span>
            <span class="n">trainables_and_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_trainables</span><span class="p">(</span><span class="n">is_viewed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span> <span class="o">=</span> <span class="n">trainables_and_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span> <span class="o">=</span> <span class="n">trainables_and_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_view</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_to_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a view of the module to a group.</span>

<span class="sd">        Groups can then be indexed. For example:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            net.cell(0).add_to_group(&quot;excitatory&quot;)</span>
<span class="sd">            net.excitatory.set(&quot;radius&quot;, 0.1)</span>

<span class="sd">        Args:</span>
<span class="sd">            group_name: The name of the group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
            <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">group_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Trying to create a group with the same name as one of the channels. &quot;</span>
                <span class="s2">&quot;This is not supported. Choose a different name for the group.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collect all recordable / clampable states in the membrane and synapses.</span>

<span class="sd">        Returns states seperated by comps and edges.&quot;&quot;&quot;</span>
        <span class="n">channel_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">channel_states</span>
        <span class="p">]</span>
        <span class="n">synapse_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">synapse_states</span>
        <span class="p">]</span>
        <span class="n">membrane_states</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">channel_states</span> <span class="o">+</span> <span class="n">membrane_states</span><span class="p">,</span>
            <span class="n">synapse_states</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_current_names</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all trainable parameters.</span>

<span class="sd">        The returned parameters should be passed to `jx.integrate(..., params=params).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of all trainable parameters in the form of</span>
<span class="sd">                [{&quot;gNa&quot;: jnp.array([0.1, 0.2, 0.3])}, ...].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_parameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">voltage_solver</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all parameters (and coupling conductances) needed to simulate.</span>

<span class="sd">        Runs `_compute_axial_conductances()` and return every parameter that is needed</span>
<span class="sd">        to solve the ODE. This includes conductances, radiuses, lengths,</span>
<span class="sd">        axial_resistivities, but also coupling conductances.</span>

<span class="sd">        This is done by first obtaining the current value of every parameter (not only</span>
<span class="sd">        the trainable ones) and then replacing the trainable ones with the value</span>
<span class="sd">        in `trainable_params()`. This function is run within `jx.integrate()`.</span>

<span class="sd">        pstate can be obtained by calling `params_to_pstate()`.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            params = module.get_parameters() # i.e. [0, 1, 2]</span>
<span class="sd">            pstate = params_to_pstate(params, module.indices_set_by_trainables)</span>
<span class="sd">            module.to_jax() # needed for call to module.jaxnodes</span>

<span class="sd">        Args:</span>
<span class="sd">            pstate: The state of the trainable parameters. pstate takes the form</span>
<span class="sd">                [{</span>
<span class="sd">                    &quot;key&quot;: &quot;gNa&quot;, &quot;indices&quot;: jnp.array([0, 1, 2]),</span>
<span class="sd">                    &quot;val&quot;: jnp.array([0.1, 0.2, 0.3])</span>
<span class="sd">                }, ...].</span>
<span class="sd">            voltage_solver: The voltage solver that is used. Since `jax.sparse` and</span>
<span class="sd">                `jaxley.xyz` require different formats of the axial conductances, this</span>
<span class="sd">                function will default to different building methods.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of all module parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">,</span> <span class="s2">&quot;capacitance&quot;</span><span class="p">]:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel_params</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">synapse_params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_param_names</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span>

        <span class="c1"># Override with those parameters set by `.make_trainable()`.</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
            <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>

            <span class="c1"># This is needed since SynapseViews worked differently before.</span>
            <span class="c1"># This mimics the old behaviour and tranformes the new indices</span>
            <span class="c1"># to the old indices.</span>
            <span class="c1"># TODO FROM #447: Longterm this should be gotten rid of.</span>
            <span class="c1"># Instead edges should work similar to nodes (would also allow for</span>
            <span class="c1"># param sharing).</span>
            <span class="n">synapse_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()[</span><span class="s2">&quot;global_edge_index&quot;</span><span class="p">]</span>
            <span class="n">synapse_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_inds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_param_names</span><span class="p">:</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="n">synapse_inds</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>  <span class="c1"># Only parameters, not initial states.</span>
                <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
                <span class="c1"># `set_param` is of shape `(num_params,)`</span>
                <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
                <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
                <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

        <span class="c1"># Compute conductance params and add them to the params dictionary.</span>
        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_compute_axial_conductances</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">params</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_states_from_nodes_and_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return states as they are set in the `.nodes` and `.edges` tables.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">to_jax</span><span class="p">()</span>  <span class="c1"># Create `.jaxnodes` from `.nodes` and `.jaxedges` from `.edges`.</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]}</span>
        <span class="c1"># Join node and edge states into a single state dictionary.</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel_states</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">:</span>
                <span class="n">states</span><span class="p">[</span><span class="n">channel_states</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_states</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">synapse_states</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_state_names</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="n">synapse_states</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_states</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">states</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the full initial state of the module from jaxnodes and trainables.</span>

<span class="sd">        Args:</span>
<span class="sd">            pstate: The state of the trainable parameters.</span>
<span class="sd">            all_params: All parameters of the module.</span>
<span class="sd">            delta_t: The time step.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of all states of the module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_get_states_from_nodes_and_edges</span><span class="p">()</span>

        <span class="c1"># Override with the initial states set by `.make_trainable()`.</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
            <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>  <span class="c1"># Only initial states, not parameters.</span>
                <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
                <span class="c1"># `set_param` is of shape `(num_params,)`</span>
                <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
                <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
                <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

        <span class="c1"># Add to the states the initial current through every channel.</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_channel_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">all_params</span>
        <span class="p">)</span>

        <span class="c1"># Add to the states the initial current through every synapse.</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_synapse_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">states</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the `Module` is ready to be solved or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_morph</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">):</span>
        <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize all mechanisms in their steady state.</span>

<span class="sd">        This considers the voltages and parameters of each compartment.</span>

<span class="sd">        Args:</span>
<span class="sd">            delta_t: Passed on to `channel.init_state()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update states of the channels.</span>
        <span class="n">channel_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_get_states_from_nodes_and_edges</span><span class="p">()</span>

        <span class="c1"># We do not use any `pstate` for initializing. In principle, we could change</span>
        <span class="c1"># that by allowing an input `params` and `pstate` to this function.</span>
        <span class="c1"># `voltage_solver` could also be `jax.sparse` here, because both of them</span>
        <span class="c1"># build the channel parameters in the same way.</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_all_parameters</span><span class="p">([],</span> <span class="n">voltage_solver</span><span class="o">=</span><span class="s2">&quot;jaxley.thomas&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="n">channel_indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span>
                <span class="s2">&quot;global_comp_index&quot;</span>
            <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">voltages</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">channel_states</span> <span class="o">=</span> <span class="n">query_channel_states_and_params</span><span class="p">(</span>
                <span class="n">states</span><span class="p">,</span> <span class="n">channel_state_names</span><span class="p">,</span> <span class="n">channel_indices</span>
            <span class="p">)</span>
            <span class="n">channel_params</span> <span class="o">=</span> <span class="n">query_channel_states_and_params</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">channel_param_names</span><span class="p">,</span> <span class="n">channel_indices</span>
            <span class="p">)</span>

            <span class="n">init_state</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">init_state</span><span class="p">(</span>
                <span class="n">channel_states</span><span class="p">,</span> <span class="n">voltages</span><span class="p">,</span> <span class="n">channel_params</span><span class="p">,</span> <span class="n">delta_t</span>
            <span class="p">)</span>

            <span class="c1"># `init_state` might not return all channel states. Only the ones that are</span>
            <span class="c1"># returned are updated here.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">init_state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Note that we are overriding `self.nodes` here, but `self.nodes` is</span>
                <span class="c1"># not used above to actually compute the current states (so there are</span>
                <span class="c1"># no issues with overriding states).</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_for_debugging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instandiates row and column inds which can be used to solve the voltage eqs.</span>

<span class="sd">        This is important only for expert users who try to modify the solver for the</span>
<span class="sd">        voltage equations. By default, this function is never run.</span>

<span class="sd">        This is useful for debugging the solver because one can use</span>
<span class="sd">        `scipy.linalg.sparse.spsolve` after every step of the solve.</span>

<span class="sd">        Here is the code snippet that can be used for debugging then (to be inserted in</span>
<span class="sd">        `solver_voltage`):</span>
<span class="sd">        ```python</span>
<span class="sd">        from scipy.sparse import csc_matrix</span>
<span class="sd">        from scipy.sparse.linalg import spsolve</span>
<span class="sd">        from jaxley.utils.debug_solver import build_voltage_matrix_elements</span>

<span class="sd">        elements, solve, num_entries, start_ind_for_branchpoints = (</span>
<span class="sd">            build_voltage_matrix_elements(</span>
<span class="sd">                uppers,</span>
<span class="sd">                lowers,</span>
<span class="sd">                diags,</span>
<span class="sd">                solves,</span>
<span class="sd">                branchpoint_conds_children[debug_states[&quot;child_inds&quot;]],</span>
<span class="sd">                branchpoint_conds_parents[debug_states[&quot;par_inds&quot;]],</span>
<span class="sd">                branchpoint_weights_children[debug_states[&quot;child_inds&quot;]],</span>
<span class="sd">                branchpoint_weights_parents[debug_states[&quot;par_inds&quot;]],</span>
<span class="sd">                branchpoint_diags,</span>
<span class="sd">                branchpoint_solves,</span>
<span class="sd">                debug_states[&quot;ncomp&quot;],</span>
<span class="sd">                nbranches,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">        sparse_matrix = csc_matrix(</span>
<span class="sd">            (elements, (debug_states[&quot;row_inds&quot;], debug_states[&quot;col_inds&quot;])),</span>
<span class="sd">            shape=(num_entries, num_entries),</span>
<span class="sd">        )</span>
<span class="sd">        solution = spsolve(sparse_matrix, solve)</span>
<span class="sd">        solution = solution[:start_ind_for_branchpoints]  # Delete branchpoint voltages.</span>
<span class="sd">        solves = jnp.reshape(solution, (debug_states[&quot;ncomp&quot;], nbranches))</span>
<span class="sd">        return solves</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For scipy and jax.scipy.</span>
        <span class="n">row_and_col_inds</span> <span class="o">=</span> <span class="n">compute_morphology_indices</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">num_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">])</span>
        <span class="n">data_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">convert_to_csc</span><span class="p">(</span>
            <span class="n">num_elements</span><span class="o">=</span><span class="n">num_elements</span><span class="p">,</span>
            <span class="n">row_ind</span><span class="o">=</span><span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">],</span>
            <span class="n">col_ind</span><span class="o">=</span><span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;col_inds&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;col_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;col_inds&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;data_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;indptr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indptr</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;ncomp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;child_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_child_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;par_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_par_inds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">comp_states</span><span class="p">,</span> <span class="n">edge_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_state_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="o">+</span> <span class="n">edge_states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> is not a recognized state in this module.&quot;</span><span class="p">)</span>
        <span class="n">in_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span> <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span>

        <span class="n">new_recs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">in_view</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;rec_index&quot;</span><span class="p">])</span>
        <span class="n">new_recs</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span><span class="p">,</span> <span class="n">new_recs</span><span class="p">])</span>
        <span class="n">has_duplicates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">has_duplicates</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">in_view</span><span class="p">)</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">has_duplicates</span><span class="p">)</span><span class="si">}</span><span class="s2"> recordings. See `.recordings` for details.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the attrs of the view after changes in the base module.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">View</span><span class="p">):</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span>
            <span class="n">current_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span>
            <span class="c1"># copy dict of new View. For some reason doing self = View(self)</span>
            <span class="c1"># did not work.</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span>
            <span class="p">)</span><span class="o">.</span><span class="vm">__dict__</span>

            <span class="c1"># retain the scope and current_view of the previous view</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">=</span> <span class="n">scope</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">=</span> <span class="n">current_view</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">delete_recordings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all recordings from the module.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">View</span><span class="p">):</span>
            <span class="n">base_recs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">base_recs</span><span class="p">[</span>
                <span class="o">~</span><span class="n">base_recs</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recordings</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_view</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">stimulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the compartment.</span>

<span class="sd">        current must be a 1d array or have batch dimension of size `(num_compartments, )`</span>
<span class="sd">        or `(1, )`. If 1d, the same stimulus is added to all compartments.</span>

<span class="sd">        This function cannot be run during `jax.jit` and `jax.grad`. Because of this,</span>
<span class="sd">        it should only be used for static stimuli (i.e., stimuli that do not depend</span>
<span class="sd">        on the data and that should not be learned). For stimuli that depend on data</span>
<span class="sd">        (or that should be learned), please use `data_stimulate()`.</span>

<span class="sd">        Args:</span>
<span class="sd">            current: Current in `nA`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clamp a state to a given value across specified compartments.</span>

<span class="sd">        Args:</span>
<span class="sd">            state_name: The name of the state to clamp.</span>
<span class="sd">            state_array (jnp.nd: Array of values to clamp the state to.</span>
<span class="sd">            verbose : If True, prints details about the clamping.</span>

<span class="sd">        This function sets external states for the compartments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_external_input</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">comp_states</span><span class="p">,</span> <span class="n">edge_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_state_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="o">+</span> <span class="n">edge_states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> is not a recognized state in this module.&quot;</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_inserted</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">is_multiple</span> <span class="o">=</span> <span class="n">num_inserted</span> <span class="o">==</span> <span class="n">batch_size</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="k">if</span> <span class="n">is_multiple</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">num_inserted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">batch_size</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="n">num_inserted</span><span class="p">,</span>
        <span class="p">],</span> <span class="s2">&quot;Number of comps and stimuli do not match.&quot;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">values</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">comp_states</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="n">num_inserted</span><span class="si">}</span><span class="s2"> external_states. See `.externals` for details.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">data_stimulate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">current</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">data_stimuli</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the module within jit (or grad).</span>

<span class="sd">        Args:</span>
<span class="sd">            current: Current in `nA`.</span>
<span class="sd">            verbose: Whether or not to print the number of inserted stimuli. `False`</span>
<span class="sd">                by default because this method is meant to be jitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_external_input</span><span class="p">(</span>
            <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">data_stimuli</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">data_clamp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">data_clamps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a clamp into the module within jit (or grad).</span>

<span class="sd">        Args:</span>
<span class="sd">            state_name: Name of the state variable to set.</span>
<span class="sd">            state_array: Time series of the state variable in the default Jaxley unit.</span>
<span class="sd">                State array should be of shape (num_clamps, simulation_time) or</span>
<span class="sd">                (simulation_time, ) for a single clamp.</span>
<span class="sd">            verbose: Whether or not to print the number of inserted clamps. `False`</span>
<span class="sd">                by default because this method is meant to be jitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comp_states</span><span class="p">,</span> <span class="n">edge_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_state_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="o">+</span> <span class="n">edge_states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> is not a recognized state in this module.&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_external_input</span><span class="p">(</span>
            <span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">data_clamps</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_data_external_input</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">data_external_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">comp_states</span><span class="p">,</span> <span class="n">edge_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_state_names</span><span class="p">()</span>
        <span class="n">state_array</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">state_array</span>
            <span class="k">if</span> <span class="n">state_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">state_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">state_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">num_inserted</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">comp_states</span>
            <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">is_multiple</span> <span class="o">=</span> <span class="n">num_inserted</span> <span class="o">==</span> <span class="n">batch_size</span>
        <span class="n">state_array</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">state_array</span>
            <span class="k">if</span> <span class="n">is_multiple</span>
            <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">state_array</span><span class="p">,</span> <span class="n">num_inserted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">batch_size</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="n">num_inserted</span><span class="p">,</span>
        <span class="p">],</span> <span class="s2">&quot;Number of comps and clamps do not match.&quot;</span>

        <span class="k">if</span> <span class="n">data_external_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">external_input</span> <span class="o">=</span> <span class="n">data_external_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">external_input</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">external_input</span><span class="p">,</span> <span class="n">state_array</span><span class="p">])</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">data_external_input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">external_input</span> <span class="o">=</span> <span class="n">state_array</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">inds</span><span class="p">,</span> <span class="n">view</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state_name</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="si">}</span><span class="s2"> stimuli.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="si">}</span><span class="s2"> clamps.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">external_input</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">delete_stimuli</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all stimuli from the module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_clamps</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">delete_clamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all clamps of the given state from the module.&quot;&quot;&quot;</span>
        <span class="n">all_externals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">all_externals</span><span class="p">:</span>
            <span class="n">all_externals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
        <span class="n">state_names</span> <span class="o">=</span> <span class="n">all_externals</span> <span class="k">if</span> <span class="n">state_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">state_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">state_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">:</span>
                <span class="n">keep_inds</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">state_name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span>
                <span class="p">)</span>
                <span class="n">base_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span>
                <span class="n">base_exts_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">keep_inds</span><span class="p">):</span>
                    <span class="n">base_exts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">base_exts_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">base_exts</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_exts</span><span class="p">[</span><span class="n">state_name</span><span class="p">][</span><span class="n">keep_inds</span><span class="p">]</span>
                    <span class="n">base_exts_inds</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_exts_inds</span><span class="p">[</span><span class="n">state_name</span><span class="p">][</span><span class="n">keep_inds</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_view</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># does not have to be deleted if not in externals</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a channel or pump into the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: The channel to insert.&quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>

        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;You are trying to insert a channel whose name is the same as one of the &quot;</span>
            <span class="s2">&quot;group names. This is not supported. Either rename the channel or use a &quot;</span>
            <span class="s2">&quot;different name for the group.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Channel does not yet exist in the `jx.Module` at all.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Channel</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span>
        <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">False</span>  <span class="c1"># Previous columns do not have the new channel.</span>
            <span class="p">)</span>
        <span class="c1"># Pump does not exist yet in the `jx.Module` at all.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">False</span>  <span class="c1"># Previous columns do not have the new channel.</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">ion_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumped_ions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">ion_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>

        <span class="c1"># Add a binary column that indicates if a channel is present.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Loop over all new parameters, e.g. gNa, eNa.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Loop over all new parameters, e.g. gNa, eNa.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">diffuse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Diffuse a particular state across compartments with Fickian diffusion.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: Name of the state that should be diffused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">diffusion_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># The diffused state might not exist in all compartments that across which</span>
        <span class="c1"># we are diffusing (e.g. there are active calcium mechanisms only in the soma,</span>
        <span class="c1"># but calcium should still diffuse into the dendrites). Here, we ensure that</span>
        <span class="c1"># the state is not `NaN` in every compartment across which we are diffusing.</span>
        <span class="n">state_is_nan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">state</span><span class="p">])</span>
        <span class="c1"># 0.0 would lead to division by zero in Nernst reversal, but states that have</span>
        <span class="c1"># the NernstReversal should have the state anyways.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">state_is_nan</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_diffusion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes ion diffusion in the entire module.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: Name of the state that should no longer be diffused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">diffusion_states</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;State </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> is not part of `self.diffusion_states`.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">diffusion_states</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a channel or pump from the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: The channel to remove.&quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
        <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">]</span>
        <span class="n">all_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
        <span class="n">all_pump_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">:</span>
            <span class="n">channel_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">channel_cols</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">channel_cols</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># only delete cols if no other comps in the module have the same channel</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Channel</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">all_channel_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">all_pump_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The channel/pump to be deleted is neither a channel nor a &quot;</span>
                        <span class="s2">&quot;pump. Maybe you ran `cell.delete(HH)` instead of &quot;</span>
                        <span class="s2">&quot;`cell.delete(HH())` (ie you forgot to initialize the channel &quot;</span>
                        <span class="s2">&quot;via round brackets: `HH()`.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">channel_cols</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> not found in the module.&quot;</span><span class="p">)</span>

    <span class="nd">@only_allow_module</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">external_inds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">externals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;bwd_euler&quot;</span><span class="p">,</span>
        <span class="n">voltage_solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;jaxley.stone&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One step of solving the Ordinary Differential Equation.</span>

<span class="sd">        This function is called inside of `integrate` and increments the state of the</span>
<span class="sd">        module by one time step. Calls `_step_channels` and `_step_synapse` to update</span>
<span class="sd">        the states of the channels and synapses.</span>

<span class="sd">        Args:</span>
<span class="sd">            u: The state of the module. voltages = u[&quot;v&quot;]</span>
<span class="sd">            delta_t: The time step.</span>
<span class="sd">            external_inds: The indices of the external inputs.</span>
<span class="sd">            externals: The external inputs.</span>
<span class="sd">            params: The parameters of the module.</span>
<span class="sd">            solver: The solver to use for the voltages. Either of [&quot;bwd_euler&quot;,</span>
<span class="sd">                &quot;fwd_euler&quot;, &quot;crank_nicolson&quot;].</span>
<span class="sd">            voltage_solver: The tridiagonal solver used to diagonalize the</span>
<span class="sd">                coefficient matrix of the ODE system. Either of [&quot;jaxley.thomas&quot;,</span>
<span class="sd">                &quot;jaxley.stone&quot;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            The updated state of the module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the external inputs</span>
        <span class="k">if</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">i_current</span> <span class="o">=</span> <span class="n">externals</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span>
            <span class="n">i_inds</span> <span class="o">=</span> <span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span>
            <span class="n">i_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_input</span><span class="p">(</span>
                <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">],</span> <span class="n">i_inds</span><span class="p">,</span> <span class="n">i_current</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_ext</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Steps of the channel &amp; pump states and computes the current through these</span>
        <span class="c1"># channels and pumps.</span>
        <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">linear_terms</span><span class="p">,</span> <span class="n">const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_channels</span><span class="p">(</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">params</span>
        <span class="p">)</span>

        <span class="c1"># Step of the synapse.</span>
        <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">v_syn_linear_terms</span><span class="p">,</span> <span class="n">v_syn_const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_synapse</span><span class="p">(</span>
            <span class="n">u</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">delta_t</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Voltage steps.</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;capacitance&quot;</span><span class="p">]</span>  <span class="c1"># Abbreviation.</span>

        <span class="c1"># Arguments used by all solvers.</span>
        <span class="n">state_vals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;states&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]],</span>
            <span class="s2">&quot;linear_terms&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">linear_terms</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">v_syn_linear_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">],</span>
            <span class="s2">&quot;constant_terms&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">const_terms</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_ext</span> <span class="o">+</span> <span class="n">v_syn_const_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">],</span>
            <span class="c1"># The axial conductances have already been divided by `cm` in the</span>
            <span class="c1"># `cell_utils.py` in the `compute_axial_conductances` method.</span>
            <span class="s2">&quot;axial_conductances&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="s2">&quot;v&quot;</span><span class="p">]],</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ion_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
                <span class="c1"># If an ion is pumped but _not_ diffused, we update the state of the ion</span>
                <span class="c1"># (i.e., its concentration) with implicit Euler. We could also use</span>
                <span class="c1"># exponential-euler here, but we use implicit Euler for consistency with</span>
                <span class="c1"># the case of the ion being diffused. TODO: In the long run, we should</span>
                <span class="c1"># give the user the option to specify the solver.</span>
                <span class="c1">#</span>
                <span class="c1"># Implicit Euler for diagonal system (i.e. all compartments are</span>
                <span class="c1"># independent):</span>
                <span class="c1">#</span>
                <span class="c1"># v_dot = const + v * linear</span>
                <span class="c1"># v_n = v_{n+1} - dt * (const + v_{n+1} * linear)</span>
                <span class="c1"># ...</span>
                <span class="c1"># v_{n+1} = (v_n + dt * const) / (1 - dt * linear)</span>
                <span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="n">const_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="n">linear_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ion_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
                <span class="c1"># Ions that are not pumped have no active component.</span>
                <span class="n">ion_linear_term</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">])</span>
                <span class="n">ion_const_term</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ion_linear_term</span> <span class="o">=</span> <span class="n">linear_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span>
                <span class="n">ion_const_term</span> <span class="o">=</span> <span class="n">const_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span>
            <span class="c1"># Append the states of the pumps if they are diffusing (the user must</span>
            <span class="c1"># manually specify ion diffusion with `cell.diffuse(ion_state_name)`). Note</span>
            <span class="c1"># that these values are _not_ divided by the capacitance `cm`.</span>
            <span class="k">if</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
                <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]]</span>
                <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;linear_terms&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ion_linear_term</span><span class="p">]</span>
                <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;constant_terms&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ion_const_term</span><span class="p">]</span>
                <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">params</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="n">ion_name</span><span class="p">]</span>
                <span class="p">]</span>

        <span class="c1"># Stack all states such that they can be handled by `vmap` in the solve.</span>
        <span class="k">for</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;states&quot;</span><span class="p">,</span>
            <span class="s2">&quot;linear_terms&quot;</span><span class="p">,</span>
            <span class="s2">&quot;constant_terms&quot;</span><span class="p">,</span>
            <span class="s2">&quot;axial_conductances&quot;</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="n">state_vals</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">state_vals</span><span class="p">[</span><span class="n">state_name</span><span class="p">])</span>

        <span class="c1"># Clamp for channels and synapses.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Add solver specific arguments.</span>
        <span class="k">if</span> <span class="n">voltage_solver</span> <span class="o">==</span> <span class="s2">&quot;jax.sparse&quot;</span><span class="p">:</span>
            <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;internal_node_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
                <span class="s2">&quot;sinks&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
                <span class="s2">&quot;data_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_inds</span><span class="p">,</span>
                <span class="s2">&quot;indices&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_jax_spsolve</span><span class="p">,</span>
                <span class="s2">&quot;indptr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indptr_jax_spsolve</span><span class="p">,</span>
                <span class="s2">&quot;n_nodes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_nodes</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="c1"># Only for `bwd_euler` and `cranck-nicolson`.</span>
            <span class="n">step_voltage_implicit</span> <span class="o">=</span> <span class="n">step_voltage_implicit_with_jax_spsolve</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Our custom sparse solver requires a different format of all conductance</span>
            <span class="c1"># values to perform triangulation and backsubstution optimally.</span>
            <span class="c1">#</span>
            <span class="c1"># Currently, the forward Euler solver also uses this format. However,</span>
            <span class="c1"># this is only for historical reasons and we are planning to change this in</span>
            <span class="c1"># the future.</span>
            <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;internal_node_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
                <span class="s2">&quot;sinks&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
                <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
                <span class="s2">&quot;types&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
                <span class="s2">&quot;ncomp_per_branch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
                <span class="s2">&quot;par_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span>
                <span class="s2">&quot;child_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span>
                <span class="s2">&quot;nbranches&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
                <span class="s2">&quot;solver&quot;</span><span class="p">:</span> <span class="n">voltage_solver</span><span class="p">,</span>
                <span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_indexer</span><span class="p">,</span>
                <span class="s2">&quot;debug_states&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="c1"># Only for `bwd_euler` and `cranck-nicolson`.</span>
            <span class="n">step_voltage_implicit</span> <span class="o">=</span> <span class="n">step_voltage_implicit_with_jaxley_spsolve</span>

        <span class="k">if</span> <span class="n">solver</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bwd_euler&quot;</span><span class="p">,</span> <span class="s2">&quot;crank_nicolson&quot;</span><span class="p">]:</span>
            <span class="c1"># Crank-Nicolson advances by half a step of backward and half a step of</span>
            <span class="c1"># forward Euler.</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;crank_nicolson&quot;</span> <span class="k">else</span> <span class="n">delta_t</span>

            <span class="k">if</span> <span class="n">voltage_solver</span> <span class="o">==</span> <span class="s2">&quot;jax.sparse&quot;</span><span class="p">:</span>
                <span class="c1"># The `jax.sparse` solver does not allow `vmap` (because it uses) the</span>
                <span class="c1"># scipy sparse solver, so we just loop here.</span>
                <span class="n">num_ions</span> <span class="o">=</span> <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">updated_states</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ion_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ions</span><span class="p">):</span>
                    <span class="n">updated_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">step_voltage_implicit</span><span class="p">(</span>
                            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;linear_terms&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;constant_terms&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                            <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                            <span class="n">dt</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">updated_states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">updated_states</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The following if-case is a bit ugly and, technically, not needed.</span>
                <span class="c1"># However, running a `vmapped` version of the implicit solver induces</span>
                <span class="c1"># significant computation cost, even if the leading dimension of the</span>
                <span class="c1"># `vmap` is 1 (as is the case if one has no diffusion). To ensure</span>
                <span class="c1"># fast runtime and compile time, the following if-case avoids the `vmap`</span>
                <span class="c1"># if one does not use diffusion.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">updated_states</span> <span class="o">=</span> <span class="n">step_voltage_implicit</span><span class="p">(</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;linear_terms&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;constant_terms&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                        <span class="n">dt</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Add `vmap` dimension.</span>
                    <span class="n">updated_states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">updated_states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nones</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver_kwargs</span><span class="p">)</span>
                    <span class="n">vmapped</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
                        <span class="n">step_voltage_implicit</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">nones</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">updated_states</span> <span class="o">=</span> <span class="n">vmapped</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">state_vals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">dt</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;crank_nicolson&quot;</span><span class="p">:</span>
                <span class="c1"># The forward Euler step in Crank-Nicolson can be performed easily as</span>
                <span class="c1"># `V_{n+1} = 2 * V_{n+1/2} - V_n`. See also NEURON book Chapter 4.</span>
                <span class="n">updated_states</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">updated_states</span> <span class="o">-</span> <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;fwd_euler&quot;</span><span class="p">:</span>
            <span class="n">nones</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver_kwargs</span><span class="p">)</span>
            <span class="n">vmapped</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">step_voltage_explicit</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">nones</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">updated_states</span> <span class="o">=</span> <span class="n">vmapped</span><span class="p">(</span>
                <span class="o">*</span><span class="n">state_vals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">delta_t</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You specified `solver=</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2">`. The only allowed solvers are &quot;</span>
                <span class="s2">&quot;[&#39;bwd_euler&#39;, &#39;fwd_euler&#39;, &#39;crank_nicolson&#39;].&quot;</span>
            <span class="p">)</span>

        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Assign the diffused ion states.</span>
        <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_states</span><span class="p">[</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Clamp for voltages.</span>
        <span class="k">if</span> <span class="s2">&quot;v&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">u</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_channels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">channel_nodes</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One step of integration of the channels and of computing their current.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_channels_state</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">channel_nodes</span><span class="p">,</span> <span class="n">params</span>
        <span class="p">)</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">channel_nodes</span><span class="p">,</span> <span class="n">params</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_channels_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">channel_nodes</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One integration step of the channels.&quot;&quot;&quot;</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="c1"># Update states of the channels.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">)</span>
            <span class="n">channel_param_names</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;radius&quot;</span><span class="p">,</span>
                <span class="s2">&quot;length&quot;</span><span class="p">,</span>
                <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">,</span>
                <span class="s2">&quot;capacitance&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">)</span>
            <span class="n">channel_state_names</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span>
            <span class="n">channel_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

            <span class="n">channel_params</span> <span class="o">=</span> <span class="n">query_channel_states_and_params</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">channel_param_names</span><span class="p">,</span> <span class="n">channel_indices</span>
            <span class="p">)</span>
            <span class="n">channel_states</span> <span class="o">=</span> <span class="n">query_channel_states_and_params</span><span class="p">(</span>
                <span class="n">states</span><span class="p">,</span> <span class="n">channel_state_names</span><span class="p">,</span> <span class="n">channel_indices</span>
            <span class="p">)</span>

            <span class="n">states_updated</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">update_states</span><span class="p">(</span>
                <span class="n">channel_states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">voltages</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">],</span> <span class="n">channel_params</span>
            <span class="p">)</span>
            <span class="c1"># Rebuild state. This has to be done within the loop over channels to allow</span>
            <span class="c1"># multiple channels which modify the same state.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">states_updated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">states</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_channel_currents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">channel_nodes</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current through each channel.</span>

<span class="sd">        This is also updates `state` because the `state` also contains the current.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute current through channels.</span>
        <span class="n">linear_terms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">const_terms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
            <span class="n">modified_state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">linear_terms</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">const_terms</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="n">current_states</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
            <span class="n">current_states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">modified_state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Channel</span><span class="p">):</span>
                <span class="n">modified_state_name</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">modified_state_name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">ion_name</span>
            <span class="n">modified_state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">modified_state_name</span><span class="p">]</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span>
                <span class="s2">&quot;global_comp_index&quot;</span>
            <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">current</span><span class="p">,</span> <span class="n">linear_term</span><span class="p">,</span> <span class="n">const_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_current_components</span><span class="p">(</span>
                <span class="n">modified_state</span><span class="p">,</span>
                <span class="n">states</span><span class="p">,</span>
                <span class="n">delta_t</span><span class="p">,</span>
                <span class="n">channel</span><span class="p">,</span>
                <span class="n">indices</span><span class="p">,</span>
                <span class="n">params</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">linear_terms</span><span class="p">[</span><span class="n">modified_state_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">linear_terms</span><span class="p">[</span><span class="n">modified_state_name</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">linear_term</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">const_terms</span><span class="p">[</span><span class="n">modified_state_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">const_terms</span><span class="p">[</span><span class="n">modified_state_name</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">const_term</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Save the current (for the unperturbed voltage) as a state that will</span>
            <span class="c1"># also be passed to the state update.</span>
            <span class="n">current_states</span><span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">current_states</span><span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Copy the currents into the `state` dictionary such that they can be</span>
        <span class="c1"># recorded and used by `Channel.update_states()`.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># * 1_000.0 to convert from mA/cm^2 to uA/cm^2.</span>
        <span class="n">linear_terms</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1000.0</span>
        <span class="n">const_terms</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1000.0</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="n">linear_terms</span><span class="p">,</span> <span class="n">const_terms</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_channel_current_components</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">modified_state</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">:</span> <span class="n">Channel</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes current through a channel and its linear and const components.</span>

<span class="sd">        The linear and constant components are inferred by running the `compute_current`</span>
<span class="sd">        twice. They are later used for implicit Euler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Run with two different voltages that are `diff` apart to infer the slope and</span>
        <span class="c1"># offset.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e-3</span>

        <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">channel_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">channel_param_names</span><span class="p">:</span>
            <span class="n">channel_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">channel_params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">channel_params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">channel_params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>

        <span class="n">channel_states</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">channel_state_names</span><span class="p">:</span>
            <span class="n">channel_states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>

        <span class="n">v_and_perturbed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">modified_state</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">modified_state</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">membrane_currents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">compute_current</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span>
            <span class="n">channel_states</span><span class="p">,</span> <span class="n">v_and_perturbed</span><span class="p">,</span> <span class="n">channel_params</span>
        <span class="p">)</span>
        <span class="n">voltage_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">membrane_currents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">membrane_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">diff</span>
        <span class="n">constant_term</span> <span class="o">=</span> <span class="n">membrane_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">voltage_term</span> <span class="o">*</span> <span class="n">modified_state</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">membrane_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">voltage_term</span><span class="p">,</span> <span class="o">-</span><span class="n">constant_term</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_synapse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One step of integration of the channels.</span>

<span class="sd">        `Network` overrides this method (because it actually has synapses), whereas</span>
<span class="sd">        `Compartment`, `Branch`, and `Cell` do not override this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_synapse_currents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">syn_channels</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_external_input</span><span class="p">(</span>
        <span class="n">voltages</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">i_inds</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">i_stim</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">length_single_compartment</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return external input to each compartment in uA / cm^2.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltages: mV.</span>
<span class="sd">            i_stim: nA.</span>
<span class="sd">            radius: um.</span>
<span class="sd">            length_single_compartment: um.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zero_vec</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">convert_point_process_to_distributed</span><span class="p">(</span>
            <span class="n">i_stim</span><span class="p">,</span> <span class="n">radius</span><span class="p">[</span><span class="n">i_inds</span><span class="p">],</span> <span class="n">length_single_compartment</span><span class="p">[</span><span class="n">i_inds</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">dnums</span> <span class="o">=</span> <span class="n">ScatterDimensionNumbers</span><span class="p">(</span>
            <span class="n">update_window_dims</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">inserted_window_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">scatter_dims_to_operand_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="n">stim_at_timestep</span> <span class="o">=</span> <span class="n">scatter_add</span><span class="p">(</span><span class="n">zero_vec</span><span class="p">,</span> <span class="n">i_inds</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">current</span><span class="p">,</span> <span class="n">dnums</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stim_at_timestep</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">        Modules can be visualized on one of the cardinal planes (xy, xz, yz) or</span>
<span class="sd">        even in 3D.</span>

<span class="sd">        Several options are available:</span>
<span class="sd">        - `line`: All points from the traced morphology (`xyzr`), are connected</span>
<span class="sd">        with a line plot.</span>
<span class="sd">        - `scatter`: All traced points, are plotted as scatter points.</span>
<span class="sd">        - `comp`: Plots the compartmentalized morphology, including radius</span>
<span class="sd">        and shape. (shows the true compartment lengths per default, but this can</span>
<span class="sd">        be changed via the `kwargs`, for details see</span>
<span class="sd">        `jaxley.utils.plot_utils.plot_comps`).</span>
<span class="sd">        - `morph`: Reconstructs the 3D shape of the traced morphology. For details see</span>
<span class="sd">        `jaxley.utils.plot_utils.plot_morph`. Warning: For 3D plots and morphologies</span>
<span class="sd">        with many traced points this can be very slow.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax: An axis into which to plot.</span>
<span class="sd">            color: The color for all branches.</span>
<span class="sd">            dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">                two of them.</span>
<span class="sd">            type: The type of plot. One of [&quot;line&quot;, &quot;scatter&quot;, &quot;comp&quot;, &quot;morph&quot;].</span>
<span class="sd">            kwargs: Keyword arguments passed to the plotting function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="s2">&quot;resolution&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;resolution&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;comp&quot;</span> <span class="ow">in</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">plot_comps</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;morph&quot;</span> <span class="ow">in</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">plot_morph</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xyzr</span><span class="p">[:,</span> <span class="n">dims</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">for</span> <span class="n">xyzr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;No coordinates available. Use `vis(detail=&#39;point&#39;)` or run `.compute_xyz()` before running `.vis()`.&quot;</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return xyz coordinates of every branch, based on the branch length.</span>

<span class="sd">        This function should not be called if the morphology was read from an `.swc`</span>
<span class="sd">        file. However, for morphologies that were constructed from scratch, this</span>
<span class="sd">        function **must** be called before `.vis()`. The computed `xyz` coordinates</span>
<span class="sd">        are only used for plotting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_y_multiplier</span> <span class="o">=</span> <span class="mf">5.0</span>
        <span class="n">min_y_multiplier</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
        <span class="n">num_children</span> <span class="o">=</span> <span class="n">_compute_num_children</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="n">index_of_child</span> <span class="o">=</span> <span class="n">_compute_index_of_child</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>

        <span class="c1"># Extract branch.</span>
        <span class="n">inds_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">)[</span>
            <span class="s2">&quot;global_comp_index&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">branch_lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds_branch</span><span class="p">]</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Different levels will get a different &quot;angle&quot; at which the children emerge from</span>
        <span class="c1"># the parents. This angle is defined by the `y_offset_multiplier`. This value</span>
        <span class="c1"># defines the range between y-location of the first and of the last child of a</span>
        <span class="c1"># parent.</span>
        <span class="n">y_offset_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">max_y_multiplier</span><span class="p">,</span> <span class="n">min_y_multiplier</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">):</span>
            <span class="c1"># For networks with mixed SWC and from-scatch neurons, only update those</span>
            <span class="c1"># branches that do not have coordingates yet.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">start_point</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="n">num_children_of_parent</span> <span class="o">=</span> <span class="n">num_children</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">num_children_of_parent</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="p">((</span><span class="n">index_of_child</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_children_of_parent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">y_offset_multiplier</span><span class="p">[</span><span class="n">levels</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">len_of_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_offset</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                <span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="n">y_offset</span><span class="p">,</span>
                    <span class="n">start_point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_point</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">start_point</span><span class="p">,</span> <span class="n">end_point</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Dummy to keey the index `endpoints[parent[b]]` above working.</span>
                <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,)))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move cells or networks by adding to their (x, y, z) coordinates.</span>

<span class="sd">        This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The amount to move in the x direction in um.</span>
<span class="sd">            y: The amount to move in the y direction in um.</span>
<span class="sd">            z: The amount to move in the z direction in um.</span>
<span class="sd">            update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">                `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">                `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_compartment_centers</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">move_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move cells or networks to a location (x, y, z).</span>

<span class="sd">        If x, y, and z are floats, then the first compartment of the first branch</span>
<span class="sd">        of the first cell is moved to that float coordinate, and everything else is</span>
<span class="sd">        shifted by the difference between that compartment&#39;s previous coordinate and</span>
<span class="sd">        the new float location.</span>

<span class="sd">        If x, y, and z are arrays, then they must each have a length equal to the number</span>
<span class="sd">        of cells being moved. Then the first compartment of the first branch of each</span>
<span class="sd">        cell is moved to the specified location.</span>

<span class="sd">        Args:</span>
<span class="sd">            update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">                `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">                `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Test if any coordinate values are NaN which would greatly affect moving</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;NaN coordinate values detected. Shift amounts cannot be computed. Please run compute_xyzr() or assign initial coordinate values.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># can only iterate over cells for networks</span>
        <span class="c1"># lambda makes sure that generator can be created multiple times</span>
        <span class="n">base_is_net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">==</span> <span class="s2">&quot;network&quot;</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="k">if</span> <span class="n">base_is_net</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>

        <span class="n">root_xyz_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">()])</span>
        <span class="n">root_xyz</span> <span class="o">=</span> <span class="n">root_xyz_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">root_xyz_cells</span>
        <span class="n">move_by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">root_xyz</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">move_by</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">move_by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">move_by</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cells_in_view</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">cell</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cells</span><span class="p">(),</span> <span class="n">move_by</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_compartment_centers</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate jaxley modules clockwise. Used only for visualization.</span>

<span class="sd">        This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">        Args:</span>
<span class="sd">            degrees: How many degrees to rotate the module by.</span>
<span class="sd">            rotation_axis: Either of {`xy` | `xz` | `yz`}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;xz&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;yz&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">degrees</span><span class="p">)]]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">]</span> <span class="o">=</span> <span class="n">rot</span>
        <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_compartment_centers</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_node_property_to_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">properties_to_import</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">pre_or_post</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Module</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy a property that is in `node` over to `edges`.</span>

<span class="sd">        By default, `.edges` does not contain the properties (radius, length, cm,</span>
<span class="sd">        channel properties,...) of the pre- and post-synaptic compartments. This</span>
<span class="sd">        method allows to copy a property of the pre- and/or post-synaptic compartment</span>
<span class="sd">        to the edges. It is then accessible as `module.edges.pre_property_name` or</span>
<span class="sd">        `module.edges.post_property_name`.</span>

<span class="sd">        Note that, if you modify the node property _after_ having run</span>
<span class="sd">        `copy_node_property_to_edges`, it will not automatically update the value in</span>
<span class="sd">        `.edges`.</span>

<span class="sd">        Note that, if this method is called on a View (e.g.</span>
<span class="sd">        `net.cell(0).copy_node_property_to_edges`), then it will return a View, but</span>
<span class="sd">        it will _not_ modify the module itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            properties_to_import: The name of the node properties that should be</span>
<span class="sd">                imported. To list all available properties, look at</span>
<span class="sd">                `module.nodes.columns`.</span>
<span class="sd">            pre_or_post: Whether to import only the pre-synaptic property (&#39;pre&#39;), only</span>
<span class="sd">                the post-synaptic property (&#39;post&#39;), or both ([&#39;pre&#39;, &#39;post&#39;]).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new module which has the property copied to the `nodes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a string is passed, wrap it as a list.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pre_or_post</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">pre_or_post</span> <span class="o">=</span> <span class="p">[</span><span class="n">pre_or_post</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties_to_import</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">properties_to_import</span> <span class="o">=</span> <span class="p">[</span><span class="n">properties_to_import</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">pre_or_post_val</span> <span class="ow">in</span> <span class="n">pre_or_post</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">pre_or_post_val</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">property_to_import</span> <span class="ow">in</span> <span class="n">properties_to_import</span><span class="p">:</span>
                <span class="c1"># Delete the column if it already exists. Otherwise it would exist</span>
                <span class="c1"># twice.</span>
                <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">property_to_import</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
                        <span class="n">columns</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">property_to_import</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[[</span><span class="n">property_to_import</span><span class="p">,</span> <span class="s2">&quot;global_comp_index&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span>
                        <span class="s2">&quot;global_comp_index&quot;</span>
                    <span class="p">),</span>
                    <span class="n">on</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_global_comp_index&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                        <span class="n">property_to_import</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">property_to_import</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">}</span>
                <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.branches" class="doc doc-heading">
            <code class=" language-python"><span class="n">branches</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.branches" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Iterate over all branches in the module.</p>
<p>Returns a generator that yields a View of each branch.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.cells" class="doc doc-heading">
            <code class=" language-python"><span class="n">cells</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.cells" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Iterate over all cells in the module.</p>
<p>Returns a generator that yields a View of each cell.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.comps" class="doc doc-heading">
            <code class=" language-python"><span class="n">comps</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.comps" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Iterate over all compartments in the module.
Can be called on any module, i.e. <code>net.comps</code>, <code>cell.comps</code> or
<code>branch.comps</code>. <code>__iter__</code> does not allow for this.</p>
<p>Returns a generator that yields a View of each compartment.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.initialized" class="doc doc-heading">
            <code class=" language-python"><span class="n">initialized</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.initialized" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Whether the <code>Module</code> is ready to be solved or not.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.shape" class="doc doc-heading">
            <code class=" language-python"><span class="n">shape</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.shape" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Returns the number of submodules contained in a module.</p>
<p>.. code-block:: python</p>
<div class="codehilite"><pre><span></span><code>network.shape = (num_cells, num_branches, num_compartments)
cell.shape = (num_branches, num_compartments)
branch.shape = (num_compartments,)
</code></pre></div>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.view" class="doc doc-heading">
            <code class=" language-python"><span class="n">view</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.view" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return view of the module.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.__getitem__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.__getitem__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Lazy indexing of the module.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lazy indexing of the module.&quot;&quot;&quot;</span>
    <span class="n">supported_parents</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;branch&quot;</span><span class="p">]</span>  <span class="c1"># cannot index into comp</span>

    <span class="n">not_group_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_view</span> <span class="ow">in</span> <span class="n">supported_parents</span> <span class="ow">or</span> <span class="n">not_group_view</span>
    <span class="p">),</span> <span class="s2">&quot;Lazy indexing is only supported for `Network`, `Cell`, `Branch` and Views thereof.&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>

    <span class="n">child_views</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childviews</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_views</span><span class="p">),</span> <span class="s2">&quot;Too many indices.&quot;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child_views</span><span class="p">):</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">view</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.__iter__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__iter__</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.__iter__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Iterate over parts of the module.</p>
<p>Internally calls <code>cells</code>, <code>branches</code>, <code>comps</code> at the appropriate level.</p>
<p>Example:</p>
<p>.. code-block:: python</p>
<div class="codehilite"><pre><span></span><code>for cell in network:
    for branch in cell:
        for comp in branch:
            print(comp.nodes.shape)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterate over parts of the module.</span>

<span class="sd">    Internally calls `cells`, `branches`, `comps` at the appropriate level.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        for cell in network:</span>
<span class="sd">            for branch in cell:</span>
<span class="sd">                for comp in branch:</span>
<span class="sd">                    print(comp.nodes.shape)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">next_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childviews</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_submodules</span><span class="p">(</span><span class="n">next_level</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.add_to_group" class="doc doc-heading">
            <code class=" language-python"><span class="n">add_to_group</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.add_to_group" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Add a view of the module to a group.</p>
<p>Groups can then be indexed. For example:</p>
<p>.. code-block:: python</p>
<div class="codehilite"><pre><span></span><code>net.cell(0).add_to_group(&quot;excitatory&quot;)
net.excitatory.set(&quot;radius&quot;, 0.1)
</code></pre></div>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>group_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the group.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">add_to_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a view of the module to a group.</span>

<span class="sd">    Groups can then be indexed. For example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        net.cell(0).add_to_group(&quot;excitatory&quot;)</span>
<span class="sd">        net.excitatory.set(&quot;radius&quot;, 0.1)</span>

<span class="sd">    Args:</span>
<span class="sd">        group_name: The name of the group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">group_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
        <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">group_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Trying to create a group with the same name as one of the channels. &quot;</span>
            <span class="s2">&quot;This is not supported. Choose a different name for the group.&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.branch" class="doc doc-heading">
            <code class=" language-python"><span class="n">branch</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.branch" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return a View of the module at the selected branches(s).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>idx</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>index of the branch to view.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View of the module at the specified branch index.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected branches(s).</span>

<span class="sd">    Args:</span>
<span class="sd">        idx: index of the branch to view.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View of the module at the specified branch index.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.cell" class="doc doc-heading">
            <code class=" language-python"><span class="n">cell</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.cell" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return a View of the module at the selected cell(s).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>idx</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>index of the cell to view.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View of the module at the specified cell index.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected cell(s).</span>

<span class="sd">    Args:</span>
<span class="sd">        idx: index of the cell to view.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View of the module at the specified cell index.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.clamp" class="doc doc-heading">
            <code class=" language-python"><span class="n">clamp</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.clamp" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Clamp a state to a given value across specified compartments.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the state to clamp.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>state_array</code>
            </td>
            <td>
                  <code><span title="jax.numpy.nd">nd</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of values to clamp the state to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>verbose</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, prints details about the clamping.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>This function sets external states for the compartments.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clamp a state to a given value across specified compartments.</span>

<span class="sd">    Args:</span>
<span class="sd">        state_name: The name of the state to clamp.</span>
<span class="sd">        state_array (jnp.nd: Array of values to clamp the state to.</span>
<span class="sd">        verbose : If True, prints details about the clamping.</span>

<span class="sd">    This function sets external states for the compartments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.comp" class="doc doc-heading">
            <code class=" language-python"><span class="n">comp</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.comp" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return a View of the module at the selected compartments(s).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>idx</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>index of the comp to view.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View of the module at the specified compartment index.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected compartments(s).</span>

<span class="sd">    Args:</span>
<span class="sd">        idx: index of the comp to view.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View of the module at the specified compartment index.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_nodes</span><span class="p">(</span><span class="s2">&quot;comp&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.compute_compartment_centers" class="doc doc-heading">
            <code class=" language-python"><span class="n">compute_compartment_centers</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.compute_compartment_centers" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Add compartment centers to nodes dataframe</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_compartment_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add compartment centers to nodes dataframe&quot;&quot;&quot;</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_coords_of_comp_centers</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">centers</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.compute_xyz" class="doc doc-heading">
            <code class=" language-python"><span class="n">compute_xyz</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.compute_xyz" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return xyz coordinates of every branch, based on the branch length.</p>
<p>This function should not be called if the morphology was read from an <code>.swc</code>
file. However, for morphologies that were constructed from scratch, this
function <strong>must</strong> be called before <code>.vis()</code>. The computed <code>xyz</code> coordinates
are only used for plotting.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2422</span>
<span class="normal">2423</span>
<span class="normal">2424</span>
<span class="normal">2425</span>
<span class="normal">2426</span>
<span class="normal">2427</span>
<span class="normal">2428</span>
<span class="normal">2429</span>
<span class="normal">2430</span>
<span class="normal">2431</span>
<span class="normal">2432</span>
<span class="normal">2433</span>
<span class="normal">2434</span>
<span class="normal">2435</span>
<span class="normal">2436</span>
<span class="normal">2437</span>
<span class="normal">2438</span>
<span class="normal">2439</span>
<span class="normal">2440</span>
<span class="normal">2441</span>
<span class="normal">2442</span>
<span class="normal">2443</span>
<span class="normal">2444</span>
<span class="normal">2445</span>
<span class="normal">2446</span>
<span class="normal">2447</span>
<span class="normal">2448</span>
<span class="normal">2449</span>
<span class="normal">2450</span>
<span class="normal">2451</span>
<span class="normal">2452</span>
<span class="normal">2453</span>
<span class="normal">2454</span>
<span class="normal">2455</span>
<span class="normal">2456</span>
<span class="normal">2457</span>
<span class="normal">2458</span>
<span class="normal">2459</span>
<span class="normal">2460</span>
<span class="normal">2461</span>
<span class="normal">2462</span>
<span class="normal">2463</span>
<span class="normal">2464</span>
<span class="normal">2465</span>
<span class="normal">2466</span>
<span class="normal">2467</span>
<span class="normal">2468</span>
<span class="normal">2469</span>
<span class="normal">2470</span>
<span class="normal">2471</span>
<span class="normal">2472</span>
<span class="normal">2473</span>
<span class="normal">2474</span>
<span class="normal">2475</span>
<span class="normal">2476</span>
<span class="normal">2477</span>
<span class="normal">2478</span>
<span class="normal">2479</span>
<span class="normal">2480</span>
<span class="normal">2481</span>
<span class="normal">2482</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return xyz coordinates of every branch, based on the branch length.</span>

<span class="sd">    This function should not be called if the morphology was read from an `.swc`</span>
<span class="sd">    file. However, for morphologies that were constructed from scratch, this</span>
<span class="sd">    function **must** be called before `.vis()`. The computed `xyz` coordinates</span>
<span class="sd">    are only used for plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_y_multiplier</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">min_y_multiplier</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
    <span class="n">num_children</span> <span class="o">=</span> <span class="n">_compute_num_children</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="n">index_of_child</span> <span class="o">=</span> <span class="n">_compute_index_of_child</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>

    <span class="c1"># Extract branch.</span>
    <span class="n">inds_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">)[</span>
        <span class="s2">&quot;global_comp_index&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">branch_lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds_branch</span><span class="p">]</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Different levels will get a different &quot;angle&quot; at which the children emerge from</span>
    <span class="c1"># the parents. This angle is defined by the `y_offset_multiplier`. This value</span>
    <span class="c1"># defines the range between y-location of the first and of the last child of a</span>
    <span class="c1"># parent.</span>
    <span class="n">y_offset_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="n">max_y_multiplier</span><span class="p">,</span> <span class="n">min_y_multiplier</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">):</span>
        <span class="c1"># For networks with mixed SWC and from-scatch neurons, only update those</span>
        <span class="c1"># branches that do not have coordingates yet.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">start_point</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="n">num_children_of_parent</span> <span class="o">=</span> <span class="n">num_children</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">num_children_of_parent</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">((</span><span class="n">index_of_child</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_children_of_parent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mf">0.5</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">y_offset_multiplier</span><span class="p">[</span><span class="n">levels</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">len_of_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_offset</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="n">start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="n">y_offset</span><span class="p">,</span>
                <span class="n">start_point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_point</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">start_point</span><span class="p">,</span> <span class="n">end_point</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Dummy to keey the index `endpoints[parent[b]]` above working.</span>
            <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,)))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.copy" class="doc doc-heading">
            <code class=" language-python"><span class="n">copy</span><span class="p">(</span><span class="n">reset_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_module</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.copy" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Extract part of a module and return a copy of its View or a new module.</p>
<p>This can be used to call <code>jx.integrate</code> on part of a Module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reset_index</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>if True, the indices of the new module are reset to start from 0.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>as_module</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>if True, a new module is returned instead of a View.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a>, <span title="jaxley.modules.base.View">View</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A part of the module or a copied view of it.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">reset_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">as_module</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Module</span><span class="p">,</span> <span class="n">View</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract part of a module and return a copy of its View or a new module.</span>

<span class="sd">    This can be used to call `jx.integrate` on part of a Module.</span>

<span class="sd">    Args:</span>
<span class="sd">        reset_index: if True, the indices of the new module are reset to start from 0.</span>
<span class="sd">        as_module: if True, a new module is returned instead of a View.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A part of the module or a copied view of it.&quot;&quot;&quot;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This method is experimental, use at your own risk.&quot;</span><span class="p">)</span>
    <span class="c1"># TODO FROM #447: add reset_index, i.e. for parents, nodes, edges etc. such that they</span>
    <span class="c1"># start from 0/-1 and are contiguous</span>
    <span class="k">if</span> <span class="n">as_module</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not yet implemented.&quot;</span><span class="p">)</span>
        <span class="c1"># initialize a new module with the same attributes</span>
    <span class="k">return</span> <span class="n">view</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.copy_node_property_to_edges" class="doc doc-heading">
            <code class=" language-python"><span class="n">copy_node_property_to_edges</span><span class="p">(</span><span class="n">properties_to_import</span><span class="p">,</span> <span class="n">pre_or_post</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">])</span></code>

<a href="#jaxley.modules.base.Module.copy_node_property_to_edges" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Copy a property that is in <code>node</code> over to <code>edges</code>.</p>
<p>By default, <code>.edges</code> does not contain the properties (radius, length, cm,
channel properties,&hellip;) of the pre- and post-synaptic compartments. This
method allows to copy a property of the pre- and/or post-synaptic compartment
to the edges. It is then accessible as <code>module.edges.pre_property_name</code> or
<code>module.edges.post_property_name</code>.</p>
<p>Note that, if you modify the node property <em>after</em> having run
<code>copy_node_property_to_edges</code>, it will not automatically update the value in
<code>.edges</code>.</p>
<p>Note that, if this method is called on a View (e.g.
<code>net.cell(0).copy_node_property_to_edges</code>), then it will return a View, but
it will <em>not</em> modify the module itself.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>properties_to_import</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the node properties that should be
imported. To list all available properties, look at
<code>module.nodes.columns</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>pre_or_post</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to import only the pre-synaptic property (&lsquo;pre&rsquo;), only
the post-synaptic property (&lsquo;post&rsquo;), or both ([&lsquo;pre&rsquo;, &lsquo;post&rsquo;]).</p>
              </div>
            </td>
            <td>
                  <code>[&#39;pre&#39;, &#39;post&#39;]</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A new module which has the property copied to the <code>nodes</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2581</span>
<span class="normal">2582</span>
<span class="normal">2583</span>
<span class="normal">2584</span>
<span class="normal">2585</span>
<span class="normal">2586</span>
<span class="normal">2587</span>
<span class="normal">2588</span>
<span class="normal">2589</span>
<span class="normal">2590</span>
<span class="normal">2591</span>
<span class="normal">2592</span>
<span class="normal">2593</span>
<span class="normal">2594</span>
<span class="normal">2595</span>
<span class="normal">2596</span>
<span class="normal">2597</span>
<span class="normal">2598</span>
<span class="normal">2599</span>
<span class="normal">2600</span>
<span class="normal">2601</span>
<span class="normal">2602</span>
<span class="normal">2603</span>
<span class="normal">2604</span>
<span class="normal">2605</span>
<span class="normal">2606</span>
<span class="normal">2607</span>
<span class="normal">2608</span>
<span class="normal">2609</span>
<span class="normal">2610</span>
<span class="normal">2611</span>
<span class="normal">2612</span>
<span class="normal">2613</span>
<span class="normal">2614</span>
<span class="normal">2615</span>
<span class="normal">2616</span>
<span class="normal">2617</span>
<span class="normal">2618</span>
<span class="normal">2619</span>
<span class="normal">2620</span>
<span class="normal">2621</span>
<span class="normal">2622</span>
<span class="normal">2623</span>
<span class="normal">2624</span>
<span class="normal">2625</span>
<span class="normal">2626</span>
<span class="normal">2627</span>
<span class="normal">2628</span>
<span class="normal">2629</span>
<span class="normal">2630</span>
<span class="normal">2631</span>
<span class="normal">2632</span>
<span class="normal">2633</span>
<span class="normal">2634</span>
<span class="normal">2635</span>
<span class="normal">2636</span>
<span class="normal">2637</span>
<span class="normal">2638</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy_node_property_to_edges</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">properties_to_import</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">pre_or_post</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Module</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy a property that is in `node` over to `edges`.</span>

<span class="sd">    By default, `.edges` does not contain the properties (radius, length, cm,</span>
<span class="sd">    channel properties,...) of the pre- and post-synaptic compartments. This</span>
<span class="sd">    method allows to copy a property of the pre- and/or post-synaptic compartment</span>
<span class="sd">    to the edges. It is then accessible as `module.edges.pre_property_name` or</span>
<span class="sd">    `module.edges.post_property_name`.</span>

<span class="sd">    Note that, if you modify the node property _after_ having run</span>
<span class="sd">    `copy_node_property_to_edges`, it will not automatically update the value in</span>
<span class="sd">    `.edges`.</span>

<span class="sd">    Note that, if this method is called on a View (e.g.</span>
<span class="sd">    `net.cell(0).copy_node_property_to_edges`), then it will return a View, but</span>
<span class="sd">    it will _not_ modify the module itself.</span>

<span class="sd">    Args:</span>
<span class="sd">        properties_to_import: The name of the node properties that should be</span>
<span class="sd">            imported. To list all available properties, look at</span>
<span class="sd">            `module.nodes.columns`.</span>
<span class="sd">        pre_or_post: Whether to import only the pre-synaptic property (&#39;pre&#39;), only</span>
<span class="sd">            the post-synaptic property (&#39;post&#39;), or both ([&#39;pre&#39;, &#39;post&#39;]).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new module which has the property copied to the `nodes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If a string is passed, wrap it as a list.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pre_or_post</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">pre_or_post</span> <span class="o">=</span> <span class="p">[</span><span class="n">pre_or_post</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties_to_import</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">properties_to_import</span> <span class="o">=</span> <span class="p">[</span><span class="n">properties_to_import</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">pre_or_post_val</span> <span class="ow">in</span> <span class="n">pre_or_post</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">pre_or_post_val</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">property_to_import</span> <span class="ow">in</span> <span class="n">properties_to_import</span><span class="p">:</span>
            <span class="c1"># Delete the column if it already exists. Otherwise it would exist</span>
            <span class="c1"># twice.</span>
            <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">property_to_import</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">property_to_import</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[[</span><span class="n">property_to_import</span><span class="p">,</span> <span class="s2">&quot;global_comp_index&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span>
                    <span class="s2">&quot;global_comp_index&quot;</span>
                <span class="p">),</span>
                <span class="n">on</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_global_comp_index&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                    <span class="n">property_to_import</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre_or_post_val</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">property_to_import</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">}</span>
            <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.data_clamp" class="doc doc-heading">
            <code class=" language-python"><span class="n">data_clamp</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">data_clamps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.data_clamp" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a clamp into the module within jit (or grad).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name of the state variable to set.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>state_array</code>
            </td>
            <td>
                  <code><span title="jax.numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Time series of the state variable in the default Jaxley unit.
State array should be of shape (num_clamps, simulation_time) or
(simulation_time, ) for a single clamp.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>verbose</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether or not to print the number of inserted clamps. <code>False</code>
by default because this method is meant to be jitted.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">data_clamp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">data_clamps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a clamp into the module within jit (or grad).</span>

<span class="sd">    Args:</span>
<span class="sd">        state_name: Name of the state variable to set.</span>
<span class="sd">        state_array: Time series of the state variable in the default Jaxley unit.</span>
<span class="sd">            State array should be of shape (num_clamps, simulation_time) or</span>
<span class="sd">            (simulation_time, ) for a single clamp.</span>
<span class="sd">        verbose: Whether or not to print the number of inserted clamps. `False`</span>
<span class="sd">            by default because this method is meant to be jitted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">comp_states</span><span class="p">,</span> <span class="n">edge_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_state_names</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">state_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="o">+</span> <span class="n">edge_states</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> is not a recognized state in this module.&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">comp_states</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_external_input</span><span class="p">(</span>
        <span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">data_clamps</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.data_set" class="doc doc-heading">
            <code class=" language-python"><span class="n">data_set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">param_state</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.data_set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Set parameter of module (or its view) to a new value within <code>jit</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>key</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the parameter to set.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>val</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The value to set the parameter to. If it is <code>jnp.ndarray</code> then it
must be of shape <code>(len(num_compartments))</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>param_state</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>State of the setted parameters, internally used such that this
function does not modify global state.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">data_set</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">param_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value within `jit`.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: The name of the parameter to set.</span>
<span class="sd">        val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">            must be of shape `(len(num_compartments))`.</span>
<span class="sd">        param_state: State of the setted parameters, internally used such that this</span>
<span class="sd">            function does not modify global state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: `data_set` does not support arrays for `val`.</span>
    <span class="n">is_node_param</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">is_node_param</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
    <span class="n">viewed_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span> <span class="k">if</span> <span class="n">is_node_param</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="n">added_param_state</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;indices&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">viewed_inds</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]),</span>
                <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
                <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)),</span>
            <span class="p">}</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">param_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param_state</span> <span class="o">+=</span> <span class="n">added_param_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_state</span> <span class="o">=</span> <span class="n">added_param_state</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Key not recognized.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">param_state</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.data_stimulate" class="doc doc-heading">
            <code class=" language-python"><span class="n">data_stimulate</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">data_stimuli</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.data_stimulate" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a stimulus into the module within jit (or grad).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>current</code>
            </td>
            <td>
                  <code><span title="jax.numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Current in <code>nA</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>verbose</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether or not to print the number of inserted stimuli. <code>False</code>
by default because this method is meant to be jitted.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">data_stimulate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">current</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">data_stimuli</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the module within jit (or grad).</span>

<span class="sd">    Args:</span>
<span class="sd">        current: Current in `nA`.</span>
<span class="sd">        verbose: Whether or not to print the number of inserted stimuli. `False`</span>
<span class="sd">            by default because this method is meant to be jitted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_external_input</span><span class="p">(</span>
        <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">data_stimuli</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.delete" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Remove a channel or pump from the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.channels.Channel" href="../mechanisms/#jaxley.channels.channel.Channel">Channel</a>, <span title="jaxley.pumps.Pump">Pump</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The channel to remove.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1880</span>
<span class="normal">1881</span>
<span class="normal">1882</span>
<span class="normal">1883</span>
<span class="normal">1884</span>
<span class="normal">1885</span>
<span class="normal">1886</span>
<span class="normal">1887</span>
<span class="normal">1888</span>
<span class="normal">1889</span>
<span class="normal">1890</span>
<span class="normal">1891</span>
<span class="normal">1892</span>
<span class="normal">1893</span>
<span class="normal">1894</span>
<span class="normal">1895</span>
<span class="normal">1896</span>
<span class="normal">1897</span>
<span class="normal">1898</span>
<span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span>
<span class="normal">1910</span>
<span class="normal">1911</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove a channel or pump from the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        channel: The channel to remove.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
    <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">]</span>
    <span class="n">all_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
    <span class="n">all_pump_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">:</span>
        <span class="n">channel_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">channel_cols</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">channel_cols</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># only delete cols if no other comps in the module have the same channel</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Channel</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">all_channel_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">all_pump_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The channel/pump to be deleted is neither a channel nor a &quot;</span>
                    <span class="s2">&quot;pump. Maybe you ran `cell.delete(HH)` instead of &quot;</span>
                    <span class="s2">&quot;`cell.delete(HH())` (ie you forgot to initialize the channel &quot;</span>
                    <span class="s2">&quot;via round brackets: `HH()`.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">channel_cols</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> not found in the module.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_clamps" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_clamps</span><span class="p">(</span><span class="n">state_name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.delete_clamps" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all clamps of the given state from the module.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1781</span>
<span class="normal">1782</span>
<span class="normal">1783</span>
<span class="normal">1784</span>
<span class="normal">1785</span>
<span class="normal">1786</span>
<span class="normal">1787</span>
<span class="normal">1788</span>
<span class="normal">1789</span>
<span class="normal">1790</span>
<span class="normal">1791</span>
<span class="normal">1792</span>
<span class="normal">1793</span>
<span class="normal">1794</span>
<span class="normal">1795</span>
<span class="normal">1796</span>
<span class="normal">1797</span>
<span class="normal">1798</span>
<span class="normal">1799</span>
<span class="normal">1800</span>
<span class="normal">1801</span>
<span class="normal">1802</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">delete_clamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all clamps of the given state from the module.&quot;&quot;&quot;</span>
    <span class="n">all_externals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">all_externals</span><span class="p">:</span>
        <span class="n">all_externals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="n">state_names</span> <span class="o">=</span> <span class="n">all_externals</span> <span class="k">if</span> <span class="n">state_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">state_name</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">state_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">:</span>
            <span class="n">keep_inds</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">state_name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span>
            <span class="p">)</span>
            <span class="n">base_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span>
            <span class="n">base_exts_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">external_inds</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">keep_inds</span><span class="p">):</span>
                <span class="n">base_exts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">base_exts_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_exts</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_exts</span><span class="p">[</span><span class="n">state_name</span><span class="p">][</span><span class="n">keep_inds</span><span class="p">]</span>
                <span class="n">base_exts_inds</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_exts_inds</span><span class="p">[</span><span class="n">state_name</span><span class="p">][</span><span class="n">keep_inds</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_view</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># does not have to be deleted if not in externals</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_diffusion" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_diffusion</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.delete_diffusion" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Deletes ion diffusion in the entire module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name of the state that should no longer be diffused.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1867</span>
<span class="normal">1868</span>
<span class="normal">1869</span>
<span class="normal">1870</span>
<span class="normal">1871</span>
<span class="normal">1872</span>
<span class="normal">1873</span>
<span class="normal">1874</span>
<span class="normal">1875</span>
<span class="normal">1876</span>
<span class="normal">1877</span>
<span class="normal">1878</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">delete_diffusion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deletes ion diffusion in the entire module.</span>

<span class="sd">    Args:</span>
<span class="sd">        state: Name of the state that should no longer be diffused.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">diffusion_states</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;State </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> is not part of `self.diffusion_states`.&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">diffusion_states</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_recordings" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_recordings</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.delete_recordings" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all recordings from the module.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">delete_recordings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all recordings from the module.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">View</span><span class="p">):</span>
        <span class="n">base_recs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">base_recs</span><span class="p">[</span>
            <span class="o">~</span><span class="n">base_recs</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recordings</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_view</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_stimuli" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_stimuli</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.delete_stimuli" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all stimuli from the module.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1777</span>
<span class="normal">1778</span>
<span class="normal">1779</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">delete_stimuli</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all stimuli from the module.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">delete_clamps</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_trainables" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_trainables</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.delete_trainables" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all trainable parameters from the module.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">delete_trainables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all trainable parameters from the module.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">View</span><span class="p">):</span>
        <span class="n">trainables_and_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_trainables</span><span class="p">(</span><span class="n">is_viewed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span> <span class="o">=</span> <span class="n">trainables_and_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span> <span class="o">=</span> <span class="n">trainables_and_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_view</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.diffuse" class="doc doc-heading">
            <code class=" language-python"><span class="n">diffuse</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.diffuse" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Diffuse a particular state across compartments with Fickian diffusion.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name of the state that should be diffused.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1848</span>
<span class="normal">1849</span>
<span class="normal">1850</span>
<span class="normal">1851</span>
<span class="normal">1852</span>
<span class="normal">1853</span>
<span class="normal">1854</span>
<span class="normal">1855</span>
<span class="normal">1856</span>
<span class="normal">1857</span>
<span class="normal">1858</span>
<span class="normal">1859</span>
<span class="normal">1860</span>
<span class="normal">1861</span>
<span class="normal">1862</span>
<span class="normal">1863</span>
<span class="normal">1864</span>
<span class="normal">1865</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">diffuse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Diffuse a particular state across compartments with Fickian diffusion.</span>

<span class="sd">    Args:</span>
<span class="sd">        state: Name of the state that should be diffused.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">diffusion_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># The diffused state might not exist in all compartments that across which</span>
    <span class="c1"># we are diffusing (e.g. there are active calcium mechanisms only in the soma,</span>
    <span class="c1"># but calcium should still diffuse into the dendrites). Here, we ensure that</span>
    <span class="c1"># the state is not `NaN` in every compartment across which we are diffusing.</span>
    <span class="n">state_is_nan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">state</span><span class="p">])</span>
    <span class="c1"># 0.0 would lead to division by zero in Nernst reversal, but states that have</span>
    <span class="c1"># the NernstReversal should have the state anyways.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">state_is_nan</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.distance" class="doc doc-heading">
            <code class=" language-python"><span class="n">distance</span><span class="p">(</span><span class="n">endpoint</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.distance" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return the direct distance between two compartments.
This does not compute the pathwise distance (which is currently not
implemented).
Args:
    endpoint: The compartment to which to compute the distance to.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="s2">&quot;View&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the direct distance between two compartments.</span>
<span class="sd">    This does not compute the pathwise distance (which is currently not</span>
<span class="sd">    implemented).</span>
<span class="sd">    Args:</span>
<span class="sd">        endpoint: The compartment to which to compute the distance to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">start_xyz</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">end_xyz</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">start_xyz</span> <span class="o">-</span> <span class="n">end_xyz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.edge" class="doc doc-heading">
            <code class=" language-python"><span class="n">edge</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.edge" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return a View of the module at the selected synapse edges(s).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>idx</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>index of the edge to view.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View of the module at the specified edge index.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected synapse edges(s).</span>

<span class="sd">    Args:</span>
<span class="sd">        idx: index of the edge to view.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View of the module at the specified edge index.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_edges</span><span class="p">(</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_all_parameters" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_all_parameters</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">voltage_solver</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.get_all_parameters" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return all parameters (and coupling conductances) needed to simulate.</p>
<p>Runs <code>_compute_axial_conductances()</code> and return every parameter that is needed
to solve the ODE. This includes conductances, radiuses, lengths,
axial_resistivities, but also coupling conductances.</p>
<p>This is done by first obtaining the current value of every parameter (not only
the trainable ones) and then replacing the trainable ones with the value
in <code>trainable_params()</code>. This function is run within <code>jx.integrate()</code>.</p>
<p>pstate can be obtained by calling <code>params_to_pstate()</code>.</p>
<p>.. code-block:: python</p>
<div class="codehilite"><pre><span></span><code>params = module.get_parameters() # i.e. [0, 1, 2]
pstate = params_to_pstate(params, module.indices_set_by_trainables)
module.to_jax() # needed for call to module.jaxnodes
</code></pre></div>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>pstate</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The state of the trainable parameters. pstate takes the form
[{
    &ldquo;key&rdquo;: &ldquo;gNa&rdquo;, &ldquo;indices&rdquo;: jnp.array([0, 1, 2]),
    &ldquo;val&rdquo;: jnp.array([0.1, 0.2, 0.3])
}, &hellip;].</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>voltage_solver</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The voltage solver that is used. Since <code>jax.sparse</code> and
<code>jaxley.xyz</code> require different formats of the axial conductances, this
function will default to different building methods.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of all module parameters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_all_parameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">voltage_solver</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all parameters (and coupling conductances) needed to simulate.</span>

<span class="sd">    Runs `_compute_axial_conductances()` and return every parameter that is needed</span>
<span class="sd">    to solve the ODE. This includes conductances, radiuses, lengths,</span>
<span class="sd">    axial_resistivities, but also coupling conductances.</span>

<span class="sd">    This is done by first obtaining the current value of every parameter (not only</span>
<span class="sd">    the trainable ones) and then replacing the trainable ones with the value</span>
<span class="sd">    in `trainable_params()`. This function is run within `jx.integrate()`.</span>

<span class="sd">    pstate can be obtained by calling `params_to_pstate()`.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        params = module.get_parameters() # i.e. [0, 1, 2]</span>
<span class="sd">        pstate = params_to_pstate(params, module.indices_set_by_trainables)</span>
<span class="sd">        module.to_jax() # needed for call to module.jaxnodes</span>

<span class="sd">    Args:</span>
<span class="sd">        pstate: The state of the trainable parameters. pstate takes the form</span>
<span class="sd">            [{</span>
<span class="sd">                &quot;key&quot;: &quot;gNa&quot;, &quot;indices&quot;: jnp.array([0, 1, 2]),</span>
<span class="sd">                &quot;val&quot;: jnp.array([0.1, 0.2, 0.3])</span>
<span class="sd">            }, ...].</span>
<span class="sd">        voltage_solver: The voltage solver that is used. Since `jax.sparse` and</span>
<span class="sd">            `jaxley.xyz` require different formats of the axial conductances, this</span>
<span class="sd">            function will default to different building methods.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary of all module parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">,</span> <span class="s2">&quot;capacitance&quot;</span><span class="p">]:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">channel_params</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">synapse_params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_param_names</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span>

    <span class="c1"># Override with those parameters set by `.make_trainable()`.</span>
    <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
        <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>

        <span class="c1"># This is needed since SynapseViews worked differently before.</span>
        <span class="c1"># This mimics the old behaviour and tranformes the new indices</span>
        <span class="c1"># to the old indices.</span>
        <span class="c1"># TODO FROM #447: Longterm this should be gotten rid of.</span>
        <span class="c1"># Instead edges should work similar to nodes (would also allow for</span>
        <span class="c1"># param sharing).</span>
        <span class="n">synapse_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()[</span><span class="s2">&quot;global_edge_index&quot;</span><span class="p">]</span>
        <span class="n">synapse_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_inds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_param_names</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">synapse_inds</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>  <span class="c1"># Only parameters, not initial states.</span>
            <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
            <span class="c1"># `set_param` is of shape `(num_params,)`</span>
            <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
            <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
            <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

    <span class="c1"># Compute conductance params and add them to the params dictionary.</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_compute_axial_conductances</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_all_states" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_all_states</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.get_all_states" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Get the full initial state of the module from jaxnodes and trainables.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>pstate</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The state of the trainable parameters.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>all_params</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>All parameters of the module.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta_t</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The time step.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of all states of the module.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_all_states</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the full initial state of the module from jaxnodes and trainables.</span>

<span class="sd">    Args:</span>
<span class="sd">        pstate: The state of the trainable parameters.</span>
<span class="sd">        all_params: All parameters of the module.</span>
<span class="sd">        delta_t: The time step.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary of all states of the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_get_states_from_nodes_and_edges</span><span class="p">()</span>

    <span class="c1"># Override with the initial states set by `.make_trainable()`.</span>
    <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
        <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>  <span class="c1"># Only initial states, not parameters.</span>
            <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
            <span class="c1"># `set_param` is of shape `(num_params,)`</span>
            <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
            <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
            <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

    <span class="c1"># Add to the states the initial current through every channel.</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_channel_currents</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">all_params</span>
    <span class="p">)</span>

    <span class="c1"># Add to the states the initial current through every synapse.</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_synapse_currents</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">states</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_parameters" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_parameters</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.get_parameters" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Get all trainable parameters.</p>
<p>The returned parameters should be passed to `jx.integrate(&hellip;, params=params).</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of all trainable parameters in the form of
[{&ldquo;gNa&rdquo;: jnp.array([0.1, 0.2, 0.3])}, &hellip;].</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get all trainable parameters.</span>

<span class="sd">    The returned parameters should be passed to `jx.integrate(..., params=params).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of all trainable parameters in the form of</span>
<span class="sd">            [{&quot;gNa&quot;: jnp.array([0.1, 0.2, 0.3])}, ...].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.init_states" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_states</span><span class="p">(</span><span class="n">delta_t</span><span class="o">=</span><span class="mf">0.025</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.init_states" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize all mechanisms in their steady state.</p>
<p>This considers the voltages and parameters of each compartment.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>delta_t</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Passed on to <code>channel.init_state()</code>.</p>
              </div>
            </td>
            <td>
                  <code>0.025</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">init_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">):</span>
    <span class="c1"># TODO FROM #447: MAKE THIS WORK FOR VIEW?</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize all mechanisms in their steady state.</span>

<span class="sd">    This considers the voltages and parameters of each compartment.</span>

<span class="sd">    Args:</span>
<span class="sd">        delta_t: Passed on to `channel.init_state()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Update states of the channels.</span>
    <span class="n">channel_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_get_states_from_nodes_and_edges</span><span class="p">()</span>

    <span class="c1"># We do not use any `pstate` for initializing. In principle, we could change</span>
    <span class="c1"># that by allowing an input `params` and `pstate` to this function.</span>
    <span class="c1"># `voltage_solver` could also be `jax.sparse` here, because both of them</span>
    <span class="c1"># build the channel parameters in the same way.</span>
    <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_all_parameters</span><span class="p">([],</span> <span class="n">voltage_solver</span><span class="o">=</span><span class="s2">&quot;jaxley.thomas&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
        <span class="n">channel_indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span>
            <span class="s2">&quot;global_comp_index&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">channel_states</span> <span class="o">=</span> <span class="n">query_channel_states_and_params</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">channel_state_names</span><span class="p">,</span> <span class="n">channel_indices</span>
        <span class="p">)</span>
        <span class="n">channel_params</span> <span class="o">=</span> <span class="n">query_channel_states_and_params</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">channel_param_names</span><span class="p">,</span> <span class="n">channel_indices</span>
        <span class="p">)</span>

        <span class="n">init_state</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">init_state</span><span class="p">(</span>
            <span class="n">channel_states</span><span class="p">,</span> <span class="n">voltages</span><span class="p">,</span> <span class="n">channel_params</span><span class="p">,</span> <span class="n">delta_t</span>
        <span class="p">)</span>

        <span class="c1"># `init_state` might not return all channel states. Only the ones that are</span>
        <span class="c1"># returned are updated here.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">init_state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Note that we are overriding `self.nodes` here, but `self.nodes` is</span>
            <span class="c1"># not used above to actually compute the current states (so there are</span>
            <span class="c1"># no issues with overriding states).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.insert" class="doc doc-heading">
            <code class=" language-python"><span class="n">insert</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.insert" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a channel or pump into the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.channels.Channel" href="../mechanisms/#jaxley.channels.channel.Channel">Channel</a>, <span title="jaxley.pumps.Pump">Pump</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The channel to insert.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1804</span>
<span class="normal">1805</span>
<span class="normal">1806</span>
<span class="normal">1807</span>
<span class="normal">1808</span>
<span class="normal">1809</span>
<span class="normal">1810</span>
<span class="normal">1811</span>
<span class="normal">1812</span>
<span class="normal">1813</span>
<span class="normal">1814</span>
<span class="normal">1815</span>
<span class="normal">1816</span>
<span class="normal">1817</span>
<span class="normal">1818</span>
<span class="normal">1819</span>
<span class="normal">1820</span>
<span class="normal">1821</span>
<span class="normal">1822</span>
<span class="normal">1823</span>
<span class="normal">1824</span>
<span class="normal">1825</span>
<span class="normal">1826</span>
<span class="normal">1827</span>
<span class="normal">1828</span>
<span class="normal">1829</span>
<span class="normal">1830</span>
<span class="normal">1831</span>
<span class="normal">1832</span>
<span class="normal">1833</span>
<span class="normal">1834</span>
<span class="normal">1835</span>
<span class="normal">1836</span>
<span class="normal">1837</span>
<span class="normal">1838</span>
<span class="normal">1839</span>
<span class="normal">1840</span>
<span class="normal">1841</span>
<span class="normal">1842</span>
<span class="normal">1843</span>
<span class="normal">1844</span>
<span class="normal">1845</span>
<span class="normal">1846</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a channel or pump into the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        channel: The channel to insert.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span><span class="p">,</span> <span class="p">(</span>
        <span class="s2">&quot;You are trying to insert a channel whose name is the same as one of the &quot;</span>
        <span class="s2">&quot;group names. This is not supported. Either rename the channel or use a &quot;</span>
        <span class="s2">&quot;different name for the group.&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Channel does not yet exist in the `jx.Module` at all.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Channel</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span>
    <span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">False</span>  <span class="c1"># Previous columns do not have the new channel.</span>
        <span class="p">)</span>
    <span class="c1"># Pump does not exist yet in the `jx.Module` at all.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">Pump</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">False</span>  <span class="c1"># Previous columns do not have the new channel.</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">ion_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pumped_ions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">ion_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>

    <span class="c1"># Add a binary column that indicates if a channel is present.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Loop over all new parameters, e.g. gNa, eNa.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1"># Loop over all new parameters, e.g. gNa, eNa.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.loc" class="doc doc-heading">
            <code class=" language-python"><span class="n">loc</span><span class="p">(</span><span class="n">at</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.loc" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return a View of the module at the selected branch location(s).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>at</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>location along the branch.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View of the module at the specified branch location.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a View of the module at the selected branch location(s).</span>

<span class="sd">    Args:</span>
<span class="sd">        at: location along the branch.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View of the module at the specified branch location.&quot;&quot;&quot;</span>
    <span class="n">global_comp_idxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">comp_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">)</span>
        <span class="n">at</span> <span class="o">=</span> <span class="n">comp_locs</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">comp_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">comp_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">global_comp_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="n">global_comp_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">global_comp_idxs</span><span class="p">)</span>
    <span class="n">orig_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span>
    <span class="c1"># global scope needed to select correct comps, for i.e. branches w. ncomp=[1,2]</span>
    <span class="c1"># loc(0.9)  will correspond to different local branches (0 vs 1).</span>
    <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">comp</span><span class="p">(</span><span class="n">global_comp_idxs</span><span class="p">)</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="n">orig_scope</span><span class="p">)</span>
    <span class="n">view</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">=</span> <span class="s2">&quot;loc&quot;</span>
    <span class="k">return</span> <span class="n">view</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.make_trainable" class="doc doc-heading">
            <code class=" language-python"><span class="n">make_trainable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.make_trainable" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Make a parameter trainable.</p>
<p>If a parameter is made trainable, it will be returned by <code>get_parameters()</code>
and should then be passed to <code>jx.integrate(..., params=params)</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>key</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name of the parameter to make trainable.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>init_val</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="list">list</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Initial value of the parameter. If <code>float</code>, the same value is
used for every created parameter. If <code>list</code>, the length of the list has
to match the number of created parameters. If <code>None</code>, the current
parameter value is used and if parameter sharing is performed that the
current parameter value is averaged over all shared parameters.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>verbose</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to print the number of parameters that are added and the
total number of parameters.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_trainable</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a parameter trainable.</span>

<span class="sd">    If a parameter is made trainable, it will be returned by `get_parameters()`</span>
<span class="sd">    and should then be passed to `jx.integrate(..., params=params)`.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: Name of the parameter to make trainable.</span>
<span class="sd">        init_val: Initial value of the parameter. If `float`, the same value is</span>
<span class="sd">            used for every created parameter. If `list`, the length of the list has</span>
<span class="sd">            to match the number of created parameters. If `None`, the current</span>
<span class="sd">            parameter value is used and if parameter sharing is performed that the</span>
<span class="sd">            current parameter value is averaged over all shared parameters.</span>
<span class="sd">        verbose: Whether to print the number of parameters that are added and the</span>
<span class="sd">            total number of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_make_trainable</span>
    <span class="p">),</span> <span class="s2">&quot;network.cell(&#39;all&#39;).make_trainable() is not supported. Use a for-loop over cells.&quot;</span>
    <span class="n">ncomps_per_branch</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">data</span>

    <span class="k">assert</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in nodes or edges&quot;</span>
    <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">),</span> <span class="s2">&quot;No settable parameters found in the selected compartments.&quot;</span>

    <span class="n">grouped_view</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">)</span>
    <span class="c1"># Because of this `x.index.values` we cannot support `make_trainable()` on</span>
    <span class="c1"># the module level for synapse parameters (but only for `SynapseView`).</span>
    <span class="n">comp_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">grouped_view</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">include_groups</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># check if all shapes in comp_inds are the same. If not the case this means</span>
    <span class="c1"># the groups in controlled_by_param have different sizes, i.e. due to different</span>
    <span class="c1"># number of comps for two different branches. In this case we pad the smaller</span>
    <span class="c1"># groups with -1 to make them the same size.</span>
    <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">])</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">constant_values</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">lens</span> <span class="o">==</span> <span class="n">max_len</span><span class="p">):</span>
        <span class="n">comp_inds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pad</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">if</span> <span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_len</span> <span class="k">else</span> <span class="n">inds</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">comp_inds</span>
        <span class="p">]</span>

    <span class="c1"># Sorted inds are only used to infer the correct starting values.</span>
    <span class="n">indices_per_param</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">comp_inds</span><span class="p">)</span>

    <span class="c1"># Assign dummy param (ignored by nanmean later). This adds a new row to the</span>
    <span class="c1"># `data` (which is, e.g., self.nodes). That new row has index `-1`, which does</span>
    <span class="c1"># not clash with any other node index (they are in</span>
    <span class="c1"># `[0, ..., num_total_comps-1]`).</span>
    <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">param_vals</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">comp_inds</span><span class="p">])</span>

    <span class="c1"># Set the value which the trainable parameter should take.</span>
    <span class="n">num_created_parameters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_per_param</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">init_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">init_val</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_created_parameters</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_created_parameters</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;len(init_val)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span><span class="si">}</span><span class="s2">, but trying to create </span><span class="si">{</span><span class="n">num_created_parameters</span><span class="si">}</span><span class="s2"> parameters.&quot;</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;init_val must a float, list, or None, but it is a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">param_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">new_params</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices_per_param</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">+=</span> <span class="n">num_created_parameters</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of newly added trainable parameters: </span><span class="si">{</span><span class="n">num_created_parameters</span><span class="si">}</span><span class="s2">. Total number of trainable parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.move" class="doc doc-heading">
            <code class=" language-python"><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.move" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Move cells or networks by adding to their (x, y, z) coordinates.</p>
<p>This function is used only for visualization. It does not affect the simulation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>x</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The amount to move in the x direction in um.</p>
              </div>
            </td>
            <td>
                  <code>0.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>y</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The amount to move in the y direction in um.</p>
              </div>
            </td>
            <td>
                  <code>0.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>z</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The amount to move in the z direction in um.</p>
              </div>
            </td>
            <td>
                  <code>0.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>update_nodes</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether <code>.nodes</code> should be updated or not. Setting this to
<code>False</code> largely speeds up moving, especially for big networks, but
<code>.nodes</code> or <code>.show</code> will not show the new xyz coordinates.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2484</span>
<span class="normal">2485</span>
<span class="normal">2486</span>
<span class="normal">2487</span>
<span class="normal">2488</span>
<span class="normal">2489</span>
<span class="normal">2490</span>
<span class="normal">2491</span>
<span class="normal">2492</span>
<span class="normal">2493</span>
<span class="normal">2494</span>
<span class="normal">2495</span>
<span class="normal">2496</span>
<span class="normal">2497</span>
<span class="normal">2498</span>
<span class="normal">2499</span>
<span class="normal">2500</span>
<span class="normal">2501</span>
<span class="normal">2502</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move cells or networks by adding to their (x, y, z) coordinates.</span>

<span class="sd">    This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: The amount to move in the x direction in um.</span>
<span class="sd">        y: The amount to move in the y direction in um.</span>
<span class="sd">        z: The amount to move in the z direction in um.</span>
<span class="sd">        update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">            `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">            `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_compartment_centers</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.move_to" class="doc doc-heading">
            <code class=" language-python"><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.move_to" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Move cells or networks to a location (x, y, z).</p>
<p>If x, y, and z are floats, then the first compartment of the first branch
of the first cell is moved to that float coordinate, and everything else is
shifted by the difference between that compartment&rsquo;s previous coordinate and
the new float location.</p>
<p>If x, y, and z are arrays, then they must each have a length equal to the number
of cells being moved. Then the first compartment of the first branch of each
cell is moved to the specified location.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>update_nodes</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether <code>.nodes</code> should be updated or not. Setting this to
<code>False</code> largely speeds up moving, especially for big networks, but
<code>.nodes</code> or <code>.show</code> will not show the new xyz coordinates.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2504</span>
<span class="normal">2505</span>
<span class="normal">2506</span>
<span class="normal">2507</span>
<span class="normal">2508</span>
<span class="normal">2509</span>
<span class="normal">2510</span>
<span class="normal">2511</span>
<span class="normal">2512</span>
<span class="normal">2513</span>
<span class="normal">2514</span>
<span class="normal">2515</span>
<span class="normal">2516</span>
<span class="normal">2517</span>
<span class="normal">2518</span>
<span class="normal">2519</span>
<span class="normal">2520</span>
<span class="normal">2521</span>
<span class="normal">2522</span>
<span class="normal">2523</span>
<span class="normal">2524</span>
<span class="normal">2525</span>
<span class="normal">2526</span>
<span class="normal">2527</span>
<span class="normal">2528</span>
<span class="normal">2529</span>
<span class="normal">2530</span>
<span class="normal">2531</span>
<span class="normal">2532</span>
<span class="normal">2533</span>
<span class="normal">2534</span>
<span class="normal">2535</span>
<span class="normal">2536</span>
<span class="normal">2537</span>
<span class="normal">2538</span>
<span class="normal">2539</span>
<span class="normal">2540</span>
<span class="normal">2541</span>
<span class="normal">2542</span>
<span class="normal">2543</span>
<span class="normal">2544</span>
<span class="normal">2545</span>
<span class="normal">2546</span>
<span class="normal">2547</span>
<span class="normal">2548</span>
<span class="normal">2549</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">move_to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move cells or networks to a location (x, y, z).</span>

<span class="sd">    If x, y, and z are floats, then the first compartment of the first branch</span>
<span class="sd">    of the first cell is moved to that float coordinate, and everything else is</span>
<span class="sd">    shifted by the difference between that compartment&#39;s previous coordinate and</span>
<span class="sd">    the new float location.</span>

<span class="sd">    If x, y, and z are arrays, then they must each have a length equal to the number</span>
<span class="sd">    of cells being moved. Then the first compartment of the first branch of each</span>
<span class="sd">    cell is moved to the specified location.</span>

<span class="sd">    Args:</span>
<span class="sd">        update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">            `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">            `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Test if any coordinate values are NaN which would greatly affect moving</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;NaN coordinate values detected. Shift amounts cannot be computed. Please run compute_xyzr() or assign initial coordinate values.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># can only iterate over cells for networks</span>
    <span class="c1"># lambda makes sure that generator can be created multiple times</span>
    <span class="n">base_is_net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_current_view</span> <span class="o">==</span> <span class="s2">&quot;network&quot;</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="k">if</span> <span class="n">base_is_net</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>

    <span class="n">root_xyz_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">()])</span>
    <span class="n">root_xyz</span> <span class="o">=</span> <span class="n">root_xyz_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">root_xyz_cells</span>
    <span class="n">move_by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">root_xyz</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">move_by</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">move_by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">move_by</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cells_in_view</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">cell</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cells</span><span class="p">(),</span> <span class="n">move_by</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span>
    <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_compartment_centers</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.rotate" class="doc doc-heading">
            <code class=" language-python"><span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">update_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.rotate" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Rotate jaxley modules clockwise. Used only for visualization.</p>
<p>This function is used only for visualization. It does not affect the simulation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>degrees</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>How many degrees to rotate the module by.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>rotation_axis</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Either of {<code>xy</code> | <code>xz</code> | <code>yz</code>}.</p>
              </div>
            </td>
            <td>
                  <code>&#39;xy&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2551</span>
<span class="normal">2552</span>
<span class="normal">2553</span>
<span class="normal">2554</span>
<span class="normal">2555</span>
<span class="normal">2556</span>
<span class="normal">2557</span>
<span class="normal">2558</span>
<span class="normal">2559</span>
<span class="normal">2560</span>
<span class="normal">2561</span>
<span class="normal">2562</span>
<span class="normal">2563</span>
<span class="normal">2564</span>
<span class="normal">2565</span>
<span class="normal">2566</span>
<span class="normal">2567</span>
<span class="normal">2568</span>
<span class="normal">2569</span>
<span class="normal">2570</span>
<span class="normal">2571</span>
<span class="normal">2572</span>
<span class="normal">2573</span>
<span class="normal">2574</span>
<span class="normal">2575</span>
<span class="normal">2576</span>
<span class="normal">2577</span>
<span class="normal">2578</span>
<span class="normal">2579</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotate jaxley modules clockwise. Used only for visualization.</span>

<span class="sd">    This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees: How many degrees to rotate the module by.</span>
<span class="sd">        rotation_axis: Either of {`xy` | `xz` | `yz`}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;xz&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;yz&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">degrees</span><span class="p">)]]</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">:</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">]</span> <span class="o">=</span> <span class="n">rot</span>
    <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_compartment_centers</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.scope" class="doc doc-heading">
            <code class=" language-python"><span class="n">scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.scope" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return a View of the module with the specified scope.</p>
<p>For example <code>cell.scope("global").branch(2).scope("local").comp(1)</code>
will return the 1<sup>st</sup> compartment of branch 2.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>scope</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>either &ldquo;global&rdquo; or &ldquo;local&rdquo;.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View with the specified scope.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a View of the module with the specified scope.</span>

<span class="sd">    For example `cell.scope(&quot;global&quot;).branch(2).scope(&quot;local&quot;).comp(1)`</span>
<span class="sd">    will return the 1st compartment of branch 2.</span>

<span class="sd">    Args:</span>
<span class="sd">        scope: either &quot;global&quot; or &quot;local&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View with the specified scope.&quot;&quot;&quot;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span>
    <span class="n">view</span><span class="o">.</span><span class="n">set_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">view</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.select" class="doc doc-heading">
            <code class=" language-python"><span class="n">select</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.select" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return View of the module filtered by specific node or edges indices.</p>
<p>The selection is made based on the <code>index</code> of the <code>self.nodes</code> or <code>self.edges</code>,
i.e., not on a local compartment index or a local row number (<code>loc</code>, not
<code>iloc</code>).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>nodes</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>indices of nodes to view. If None, all nodes are viewed.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>edges</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>indices of edges to view. If None, all edges are viewed.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sorted</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>if True, nodes and edges are sorted.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="jaxley.modules.base.View">View</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>View for subset of selected nodes and/or edges.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return View of the module filtered by specific node or edges indices.</span>

<span class="sd">    The selection is made based on the `index` of the `self.nodes` or `self.edges`,</span>
<span class="sd">    i.e., not on a local compartment index or a local row number (`loc`, not</span>
<span class="sd">    `iloc`).</span>

<span class="sd">    Args:</span>
<span class="sd">        nodes: indices of nodes to view. If None, all nodes are viewed.</span>
<span class="sd">        edges: indices of edges to view. If None, all edges are viewed.</span>
<span class="sd">        sorted: if True, nodes and edges are sorted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        View for subset of selected nodes and/or edges.&quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">else</span> <span class="n">nodes</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sorted</span> <span class="k">else</span> <span class="n">nodes</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reformat_index</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span> <span class="k">if</span> <span class="n">is_str_all</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">else</span> <span class="n">edges</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sorted</span> <span class="k">else</span> <span class="n">edges</span>

    <span class="n">view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
    <span class="n">view</span><span class="o">.</span><span class="n">_set_controlled_by_param</span><span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">view</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.set" class="doc doc-heading">
            <code class=" language-python"><span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Set parameter of module (or its view) to a new value.</p>
<p>Note that this function can not be called within <code>jax.jit</code> or <code>jax.grad</code>.
Instead, it should be used set the parameters of the module <strong>before</strong> the
simulation. Use <code>.data_set()</code> to set parameters during <code>jax.jit</code> or
<code>jax.grad</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>key</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the parameter to set.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>val</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The value to set the parameter to. If it is <code>jnp.ndarray</code> then it
must be of shape <code>(len(num_compartments))</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value.</span>

<span class="sd">    Note that this function can not be called within `jax.jit` or `jax.grad`.</span>
<span class="sd">    Instead, it should be used set the parameters of the module **before** the</span>
<span class="sd">    simulation. Use `.data_set()` to set parameters during `jax.jit` or</span>
<span class="sd">    `jax.grad`.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: The name of the parameter to set.</span>
<span class="sd">        val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">            must be of shape `(len(num_compartments))`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_diffusion_</span><span class="si">{</span><span class="n">ion_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You are trying to set `</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">` to `</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">`. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;We only allow strictly positive values for the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;diffusion. Zero is not allowed either, but you can use very small &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;values (e.g. 1e-8).&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes_in_view</span><span class="p">[</span><span class="n">not_nan</span><span class="p">],</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span><span class="p">[</span><span class="n">not_nan</span><span class="p">],</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in nodes or edges&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.set_ncomp" class="doc doc-heading">
            <code class=" language-python"><span class="n">set_ncomp</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span> <span class="n">min_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.set_ncomp" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Set the number of compartments with which the branch is discretized.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ncomp</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of compartments that the branch should be discretized
into.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>min_radius</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Only used if the morphology was read from an SWC file. If passed
the radius is capped to be at least this value.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_ncomp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">ncomp</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the number of compartments with which the branch is discretized.</span>

<span class="sd">    Args:</span>
<span class="sd">        ncomp: The number of compartments that the branch should be discretized</span>
<span class="sd">            into.</span>
<span class="sd">        min_radius: Only used if the morphology was read from an SWC file. If passed</span>
<span class="sd">            the radius is capped to be at least this value.</span>

<span class="sd">    Raises:</span>
<span class="sd">        - When there are stimuli in any compartment in the module.</span>
<span class="sd">        - When there are recordings in any compartment in the module.</span>
<span class="sd">        - When the channels of the compartments are not the same within the branch</span>
<span class="sd">        that is modified.</span>
<span class="sd">        - When the lengths of the compartments are not the same within the branch</span>
<span class="sd">        that is modified.</span>
<span class="sd">        - When the branch that is modified has compartments belonging to different</span>
<span class="sd">        groups.</span>
<span class="sd">        - Unless the morphology was read from an SWC file, when the radiuses of the</span>
<span class="sd">        compartments are not the same within the branch that is modified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">externals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No stimuli allowed!&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">recordings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No recordings allowed!&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No trainables allowed!&quot;</span>

    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_module_type</span> <span class="o">!=</span> <span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;This is not allowed for networks.&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_module_type</span> <span class="o">==</span> <span class="s2">&quot;cell&quot;</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_branches_in_view</span><span class="p">)</span>
    <span class="p">),</span> <span class="s2">&quot;This is not allowed for cells.&quot;</span>

    <span class="c1"># Update all attributes that are affected by compartment structure.</span>
    <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">all_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">start_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp_per_branch</span>
    <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
    <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">channel_params</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">channel_states</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">channels</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">radius_generating_fns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_radius_generating_fns</span>

    <span class="n">within_branch_radiuses</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">compartment_lengths</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">num_previous_ncomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">within_branch_radiuses</span><span class="p">)</span>
    <span class="n">branch_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">])</span>

    <span class="n">error_msg</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;You previously modified the </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> of individual compartments, but &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;now you are modifying the number of compartments in this branch. &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;This is not allowed. First build the morphology with `set_ncomp()` and &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;then modify the radiuses and lengths of compartments.&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">within_branch_radiuses</span> <span class="o">==</span> <span class="n">within_branch_radiuses</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="ow">and</span> <span class="n">radius_generating_fns</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;capacitance&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">]:</span>
        <span class="n">compartment_properties</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">compartment_properties</span> <span class="o">==</span> <span class="n">compartment_properties</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">(</span><span class="n">property_name</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">channel_names</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Some channel exists only in some compartments of the branch which you&quot;</span>
            <span class="s2">&quot;are trying to modify. This is not allowed. First specify the number&quot;</span>
            <span class="s2">&quot;of compartments with `.set_ncomp()` and then insert the channels&quot;</span>
            <span class="s2">&quot;accordingly.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">channel_param_names</span> <span class="o">+</span> <span class="n">channel_state_names</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Some channel has different parameters or states between the &quot;</span>
            <span class="s2">&quot;different compartments of the branch which you are trying to modify. &quot;</span>
            <span class="s2">&quot;This is not allowed. First specify the number of compartments with &quot;</span>
            <span class="s2">&quot;`.set_ncomp()` and then insert the channels accordingly.&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_names</span><span class="p">:</span>
        <span class="n">group_ncomp</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">group_ncomp</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">group_ncomp</span> <span class="o">==</span> <span class="n">num_previous_ncomp</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_ncomp</span><span class="si">}</span><span class="s2"> compartments within the branch are part of the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;group &#39;</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s2">&#39;, but the other &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_previous_ncomp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">group_ncomp</span><span class="si">}</span><span class="s2"> compartments are not. This &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;is not allowed: Every compartment must belong to the same group for &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;`.set_ncomp()` to work.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Add new rows as the average of all rows. Special case for the length is below.</span>
    <span class="n">average_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">average_row</span> <span class="o">=</span> <span class="n">average_row</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="o">*</span><span class="p">[</span><span class="n">average_row</span><span class="p">]</span> <span class="o">*</span> <span class="n">ncomp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">)</span>

    <span class="c1"># Set the correct datatype after having performed an average which cast</span>
    <span class="c1"># everything to float.</span>
    <span class="n">integer_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">,</span> <span class="s2">&quot;global_branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span>
    <span class="n">view</span><span class="p">[</span><span class="n">integer_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">integer_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Whether or not a channel or group exists in a compartment is a boolean.</span>
    <span class="n">boolean_cols</span> <span class="o">=</span> <span class="n">channel_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_names</span>
    <span class="n">view</span><span class="p">[</span><span class="n">boolean_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="n">boolean_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Special treatment for the lengths and radiuses. These are not being set as</span>
    <span class="c1"># the average because we:</span>
    <span class="c1"># 1) Want to maintain the total length of a branch.</span>
    <span class="c1"># 2) Want to use the SWC inferred radius.</span>
    <span class="c1">#</span>
    <span class="c1"># Compute new compartment lengths.</span>
    <span class="n">comp_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">compartment_lengths</span><span class="p">)</span> <span class="o">/</span> <span class="n">ncomp</span>
    <span class="n">view</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_lengths</span>

    <span class="c1"># Compute new compartment radiuses.</span>
    <span class="k">if</span> <span class="n">radius_generating_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">view</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">build_radiuses_from_xyzr</span><span class="p">(</span>
            <span class="n">radius_fns</span><span class="o">=</span><span class="n">radius_generating_fns</span><span class="p">,</span>
            <span class="n">branch_indices</span><span class="o">=</span><span class="n">branch_indices</span><span class="p">,</span>
            <span class="n">min_radius</span><span class="o">=</span><span class="n">min_radius</span><span class="p">,</span>
            <span class="n">ncomp</span><span class="o">=</span><span class="n">ncomp</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">view</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">within_branch_radiuses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span>

    <span class="c1"># Update `.nodes`.</span>
    <span class="c1"># 1) Delete N rows starting from start_idx</span>
    <span class="n">number_deleted</span> <span class="o">=</span> <span class="n">num_previous_ncomp</span>
    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">number_deleted</span><span class="p">))</span>

    <span class="c1"># 2) Insert M new rows at the same location</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">start_idx</span><span class="p">]</span>  <span class="c1"># Rows before the insertion point</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:]</span>  <span class="c1"># Rows after the insertion point</span>

    <span class="c1"># 3) Combine the parts: before, new rows, and after</span>
    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df1</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">df2</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Override `comp_index` to just be a consecutive list.</span>
    <span class="n">all_nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">))</span>

    <span class="c1"># Update compartment structure arguments.</span>
    <span class="n">ncomp_per_branch</span><span class="p">[</span><span class="n">branch_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncomp</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ncomp_per_branch</span><span class="p">))</span>
    <span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="n">ncomp_per_branch</span><span class="p">)</span>
    <span class="n">internal_node_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">all_nodes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">ncomp_per_branch</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="n">ncomp</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_ncomp</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">internal_node_inds</span>

    <span class="c1"># Update the morphology indexing (e.g., `.comp_edges`).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.set_scope" class="doc doc-heading">
            <code class=" language-python"><span class="n">set_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.set_scope" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Toggle between &ldquo;global&rdquo; or &ldquo;local&rdquo; scope.</p>
<p>Determines if global or local indices are used for viewing the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>scope</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>either &ldquo;global&rdquo; or &ldquo;local&rdquo;.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Toggle between &quot;global&quot; or &quot;local&quot; scope.</span>

<span class="sd">    Determines if global or local indices are used for viewing the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        scope: either &quot;global&quot; or &quot;local&quot;.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">scope</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="s2">&quot;local&quot;</span><span class="p">],</span> <span class="s2">&quot;Invalid scope.&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">=</span> <span class="n">scope</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.show" class="doc doc-heading">
            <code class=" language-python"><span class="n">show</span><span class="p">(</span><span class="n">param_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.show" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Print detailed information about the Module or a view of it.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>param_names</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.List">List</span>[<span title="str">str</span>]]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the parameters to show. If <code>None</code>, all parameters
are shown.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>indices</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the indices of the compartments.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>params</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the parameters of the compartments.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>states</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the states of the compartments.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel_names</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the channels to show. If <code>None</code>, all channels are
shown.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A <code>pd.DataFrame</code> with the requested information.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">show</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">param_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">states</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">channel_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print detailed information about the Module or a view of it.</span>

<span class="sd">    Args:</span>
<span class="sd">        param_names: The names of the parameters to show. If `None`, all parameters</span>
<span class="sd">            are shown.</span>
<span class="sd">        indices: Whether to show the indices of the compartments.</span>
<span class="sd">        params: Whether to show the parameters of the compartments.</span>
<span class="sd">        states: Whether to show the states of the compartments.</span>
<span class="sd">        channel_names: The names of the channels to show. If `None`, all channels are</span>
<span class="sd">            shown.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `pd.DataFrame` with the requested information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># prevents this from being edited</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">,</span> <span class="s2">&quot;branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
    <span class="n">scopes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;local&quot;</span><span class="p">,</span> <span class="s2">&quot;global&quot;</span><span class="p">]</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scopes</span><span class="p">]</span> <span class="k">if</span> <span class="n">indices</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">cols</span> <span class="o">+=</span> <span class="n">inds</span>
    <span class="n">cols</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span> <span class="k">if</span> <span class="n">channel_names</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">cols</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">channel_params</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">],</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="p">)</span>
    <span class="n">cols</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="nb">sum</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">channel_states</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">],</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">states</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">param_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">inds</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">params</span>
            <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">nodes</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.step" class="doc doc-heading">
            <code class=" language-python"><span class="n">step</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">external_inds</span><span class="p">,</span> <span class="n">externals</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;bwd_euler&#39;</span><span class="p">,</span> <span class="n">voltage_solver</span><span class="o">=</span><span class="s1">&#39;jaxley.stone&#39;</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.step" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>One step of solving the Ordinary Differential Equation.</p>
<p>This function is called inside of <code>integrate</code> and increments the state of the
module by one time step. Calls <code>_step_channels</code> and <code>_step_synapse</code> to update
the states of the channels and synapses.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>u</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The state of the module. voltages = u[&ldquo;v&rdquo;]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta_t</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The time step.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>external_inds</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices of the external inputs.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>externals</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The external inputs.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>params</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The parameters of the module.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>solver</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The solver to use for the voltages. Either of [&ldquo;bwd_euler&rdquo;,
&ldquo;fwd_euler&rdquo;, &ldquo;crank_nicolson&rdquo;].</p>
              </div>
            </td>
            <td>
                  <code>&#39;bwd_euler&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>voltage_solver</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The tridiagonal solver used to diagonalize the
coefficient matrix of the ODE system. Either of [&ldquo;jaxley.thomas&rdquo;,
&ldquo;jaxley.stone&rdquo;].</p>
              </div>
            </td>
            <td>
                  <code>&#39;jaxley.stone&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated state of the module.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1913</span>
<span class="normal">1914</span>
<span class="normal">1915</span>
<span class="normal">1916</span>
<span class="normal">1917</span>
<span class="normal">1918</span>
<span class="normal">1919</span>
<span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span>
<span class="normal">1946</span>
<span class="normal">1947</span>
<span class="normal">1948</span>
<span class="normal">1949</span>
<span class="normal">1950</span>
<span class="normal">1951</span>
<span class="normal">1952</span>
<span class="normal">1953</span>
<span class="normal">1954</span>
<span class="normal">1955</span>
<span class="normal">1956</span>
<span class="normal">1957</span>
<span class="normal">1958</span>
<span class="normal">1959</span>
<span class="normal">1960</span>
<span class="normal">1961</span>
<span class="normal">1962</span>
<span class="normal">1963</span>
<span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span>
<span class="normal">1981</span>
<span class="normal">1982</span>
<span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span>
<span class="normal">2000</span>
<span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span>
<span class="normal">2011</span>
<span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span>
<span class="normal">2015</span>
<span class="normal">2016</span>
<span class="normal">2017</span>
<span class="normal">2018</span>
<span class="normal">2019</span>
<span class="normal">2020</span>
<span class="normal">2021</span>
<span class="normal">2022</span>
<span class="normal">2023</span>
<span class="normal">2024</span>
<span class="normal">2025</span>
<span class="normal">2026</span>
<span class="normal">2027</span>
<span class="normal">2028</span>
<span class="normal">2029</span>
<span class="normal">2030</span>
<span class="normal">2031</span>
<span class="normal">2032</span>
<span class="normal">2033</span>
<span class="normal">2034</span>
<span class="normal">2035</span>
<span class="normal">2036</span>
<span class="normal">2037</span>
<span class="normal">2038</span>
<span class="normal">2039</span>
<span class="normal">2040</span>
<span class="normal">2041</span>
<span class="normal">2042</span>
<span class="normal">2043</span>
<span class="normal">2044</span>
<span class="normal">2045</span>
<span class="normal">2046</span>
<span class="normal">2047</span>
<span class="normal">2048</span>
<span class="normal">2049</span>
<span class="normal">2050</span>
<span class="normal">2051</span>
<span class="normal">2052</span>
<span class="normal">2053</span>
<span class="normal">2054</span>
<span class="normal">2055</span>
<span class="normal">2056</span>
<span class="normal">2057</span>
<span class="normal">2058</span>
<span class="normal">2059</span>
<span class="normal">2060</span>
<span class="normal">2061</span>
<span class="normal">2062</span>
<span class="normal">2063</span>
<span class="normal">2064</span>
<span class="normal">2065</span>
<span class="normal">2066</span>
<span class="normal">2067</span>
<span class="normal">2068</span>
<span class="normal">2069</span>
<span class="normal">2070</span>
<span class="normal">2071</span>
<span class="normal">2072</span>
<span class="normal">2073</span>
<span class="normal">2074</span>
<span class="normal">2075</span>
<span class="normal">2076</span>
<span class="normal">2077</span>
<span class="normal">2078</span>
<span class="normal">2079</span>
<span class="normal">2080</span>
<span class="normal">2081</span>
<span class="normal">2082</span>
<span class="normal">2083</span>
<span class="normal">2084</span>
<span class="normal">2085</span>
<span class="normal">2086</span>
<span class="normal">2087</span>
<span class="normal">2088</span>
<span class="normal">2089</span>
<span class="normal">2090</span>
<span class="normal">2091</span>
<span class="normal">2092</span>
<span class="normal">2093</span>
<span class="normal">2094</span>
<span class="normal">2095</span>
<span class="normal">2096</span>
<span class="normal">2097</span>
<span class="normal">2098</span>
<span class="normal">2099</span>
<span class="normal">2100</span>
<span class="normal">2101</span>
<span class="normal">2102</span>
<span class="normal">2103</span>
<span class="normal">2104</span>
<span class="normal">2105</span>
<span class="normal">2106</span>
<span class="normal">2107</span>
<span class="normal">2108</span>
<span class="normal">2109</span>
<span class="normal">2110</span>
<span class="normal">2111</span>
<span class="normal">2112</span>
<span class="normal">2113</span>
<span class="normal">2114</span>
<span class="normal">2115</span>
<span class="normal">2116</span>
<span class="normal">2117</span>
<span class="normal">2118</span>
<span class="normal">2119</span>
<span class="normal">2120</span>
<span class="normal">2121</span>
<span class="normal">2122</span>
<span class="normal">2123</span>
<span class="normal">2124</span>
<span class="normal">2125</span>
<span class="normal">2126</span>
<span class="normal">2127</span>
<span class="normal">2128</span>
<span class="normal">2129</span>
<span class="normal">2130</span>
<span class="normal">2131</span>
<span class="normal">2132</span>
<span class="normal">2133</span>
<span class="normal">2134</span>
<span class="normal">2135</span>
<span class="normal">2136</span>
<span class="normal">2137</span>
<span class="normal">2138</span>
<span class="normal">2139</span>
<span class="normal">2140</span>
<span class="normal">2141</span>
<span class="normal">2142</span>
<span class="normal">2143</span>
<span class="normal">2144</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">external_inds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">externals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;bwd_euler&quot;</span><span class="p">,</span>
    <span class="n">voltage_solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;jaxley.stone&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;One step of solving the Ordinary Differential Equation.</span>

<span class="sd">    This function is called inside of `integrate` and increments the state of the</span>
<span class="sd">    module by one time step. Calls `_step_channels` and `_step_synapse` to update</span>
<span class="sd">    the states of the channels and synapses.</span>

<span class="sd">    Args:</span>
<span class="sd">        u: The state of the module. voltages = u[&quot;v&quot;]</span>
<span class="sd">        delta_t: The time step.</span>
<span class="sd">        external_inds: The indices of the external inputs.</span>
<span class="sd">        externals: The external inputs.</span>
<span class="sd">        params: The parameters of the module.</span>
<span class="sd">        solver: The solver to use for the voltages. Either of [&quot;bwd_euler&quot;,</span>
<span class="sd">            &quot;fwd_euler&quot;, &quot;crank_nicolson&quot;].</span>
<span class="sd">        voltage_solver: The tridiagonal solver used to diagonalize the</span>
<span class="sd">            coefficient matrix of the ODE system. Either of [&quot;jaxley.thomas&quot;,</span>
<span class="sd">            &quot;jaxley.stone&quot;].</span>

<span class="sd">    Returns:</span>
<span class="sd">        The updated state of the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract the external inputs</span>
    <span class="k">if</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">i_current</span> <span class="o">=</span> <span class="n">externals</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span>
        <span class="n">i_inds</span> <span class="o">=</span> <span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span>
        <span class="n">i_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_input</span><span class="p">(</span>
            <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">],</span> <span class="n">i_inds</span><span class="p">,</span> <span class="n">i_current</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i_ext</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Steps of the channel &amp; pump states and computes the current through these</span>
    <span class="c1"># channels and pumps.</span>
    <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">linear_terms</span><span class="p">,</span> <span class="n">const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_channels</span><span class="p">(</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">params</span>
    <span class="p">)</span>

    <span class="c1"># Step of the synapse.</span>
    <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">v_syn_linear_terms</span><span class="p">,</span> <span class="n">v_syn_const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_synapse</span><span class="p">(</span>
        <span class="n">u</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Voltage steps.</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;capacitance&quot;</span><span class="p">]</span>  <span class="c1"># Abbreviation.</span>

    <span class="c1"># Arguments used by all solvers.</span>
    <span class="n">state_vals</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;states&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]],</span>
        <span class="s2">&quot;linear_terms&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">linear_terms</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">v_syn_linear_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">],</span>
        <span class="s2">&quot;constant_terms&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">const_terms</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_ext</span> <span class="o">+</span> <span class="n">v_syn_const_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">],</span>
        <span class="c1"># The axial conductances have already been divided by `cm` in the</span>
        <span class="c1"># `cell_utils.py` in the `compute_axial_conductances` method.</span>
        <span class="s2">&quot;axial_conductances&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="s2">&quot;v&quot;</span><span class="p">]],</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ion_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
            <span class="c1"># If an ion is pumped but _not_ diffused, we update the state of the ion</span>
            <span class="c1"># (i.e., its concentration) with implicit Euler. We could also use</span>
            <span class="c1"># exponential-euler here, but we use implicit Euler for consistency with</span>
            <span class="c1"># the case of the ion being diffused. TODO: In the long run, we should</span>
            <span class="c1"># give the user the option to specify the solver.</span>
            <span class="c1">#</span>
            <span class="c1"># Implicit Euler for diagonal system (i.e. all compartments are</span>
            <span class="c1"># independent):</span>
            <span class="c1">#</span>
            <span class="c1"># v_dot = const + v * linear</span>
            <span class="c1"># v_n = v_{n+1} - dt * (const + v_{n+1} * linear)</span>
            <span class="c1"># ...</span>
            <span class="c1"># v_{n+1} = (v_n + dt * const) / (1 - dt * linear)</span>
            <span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="n">const_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">delta_t</span> <span class="o">*</span> <span class="n">linear_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">for</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ion_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pumped_ions</span><span class="p">:</span>
            <span class="c1"># Ions that are not pumped have no active component.</span>
            <span class="n">ion_linear_term</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">])</span>
            <span class="n">ion_const_term</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ion_linear_term</span> <span class="o">=</span> <span class="n">linear_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span>
            <span class="n">ion_const_term</span> <span class="o">=</span> <span class="n">const_terms</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span>
        <span class="c1"># Append the states of the pumps if they are diffusing (the user must</span>
        <span class="c1"># manually specify ion diffusion with `cell.diffuse(ion_state_name)`). Note</span>
        <span class="c1"># that these values are _not_ divided by the capacitance `cm`.</span>
        <span class="k">if</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">:</span>
            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]]</span>
            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;linear_terms&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ion_linear_term</span><span class="p">]</span>
            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;constant_terms&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ion_const_term</span><span class="p">]</span>
            <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">params</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="n">ion_name</span><span class="p">]</span>
            <span class="p">]</span>

    <span class="c1"># Stack all states such that they can be handled by `vmap` in the solve.</span>
    <span class="k">for</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;states&quot;</span><span class="p">,</span>
        <span class="s2">&quot;linear_terms&quot;</span><span class="p">,</span>
        <span class="s2">&quot;constant_terms&quot;</span><span class="p">,</span>
        <span class="s2">&quot;axial_conductances&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="n">state_vals</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">state_vals</span><span class="p">[</span><span class="n">state_name</span><span class="p">])</span>

    <span class="c1"># Clamp for channels and synapses.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="c1"># Add solver specific arguments.</span>
    <span class="k">if</span> <span class="n">voltage_solver</span> <span class="o">==</span> <span class="s2">&quot;jax.sparse&quot;</span><span class="p">:</span>
        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;internal_node_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
            <span class="s2">&quot;sinks&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
            <span class="s2">&quot;data_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_inds</span><span class="p">,</span>
            <span class="s2">&quot;indices&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_jax_spsolve</span><span class="p">,</span>
            <span class="s2">&quot;indptr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indptr_jax_spsolve</span><span class="p">,</span>
            <span class="s2">&quot;n_nodes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_nodes</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># Only for `bwd_euler` and `cranck-nicolson`.</span>
        <span class="n">step_voltage_implicit</span> <span class="o">=</span> <span class="n">step_voltage_implicit_with_jax_spsolve</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Our custom sparse solver requires a different format of all conductance</span>
        <span class="c1"># values to perform triangulation and backsubstution optimally.</span>
        <span class="c1">#</span>
        <span class="c1"># Currently, the forward Euler solver also uses this format. However,</span>
        <span class="c1"># this is only for historical reasons and we are planning to change this in</span>
        <span class="c1"># the future.</span>
        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;internal_node_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
            <span class="s2">&quot;sinks&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
            <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
            <span class="s2">&quot;types&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()),</span>
            <span class="s2">&quot;ncomp_per_branch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
            <span class="s2">&quot;par_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span>
            <span class="s2">&quot;child_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span>
            <span class="s2">&quot;nbranches&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
            <span class="s2">&quot;solver&quot;</span><span class="p">:</span> <span class="n">voltage_solver</span><span class="p">,</span>
            <span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_indexer</span><span class="p">,</span>
            <span class="s2">&quot;debug_states&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># Only for `bwd_euler` and `cranck-nicolson`.</span>
        <span class="n">step_voltage_implicit</span> <span class="o">=</span> <span class="n">step_voltage_implicit_with_jaxley_spsolve</span>

    <span class="k">if</span> <span class="n">solver</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bwd_euler&quot;</span><span class="p">,</span> <span class="s2">&quot;crank_nicolson&quot;</span><span class="p">]:</span>
        <span class="c1"># Crank-Nicolson advances by half a step of backward and half a step of</span>
        <span class="c1"># forward Euler.</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;crank_nicolson&quot;</span> <span class="k">else</span> <span class="n">delta_t</span>

        <span class="k">if</span> <span class="n">voltage_solver</span> <span class="o">==</span> <span class="s2">&quot;jax.sparse&quot;</span><span class="p">:</span>
            <span class="c1"># The `jax.sparse` solver does not allow `vmap` (because it uses) the</span>
            <span class="c1"># scipy sparse solver, so we just loop here.</span>
            <span class="n">num_ions</span> <span class="o">=</span> <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">updated_states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ion_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ions</span><span class="p">):</span>
                <span class="n">updated_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">step_voltage_implicit</span><span class="p">(</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;linear_terms&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;constant_terms&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                        <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="n">ion_ind</span><span class="p">],</span>
                        <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                        <span class="n">dt</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">updated_states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">updated_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The following if-case is a bit ugly and, technically, not needed.</span>
            <span class="c1"># However, running a `vmapped` version of the implicit solver induces</span>
            <span class="c1"># significant computation cost, even if the leading dimension of the</span>
            <span class="c1"># `vmap` is 1 (as is the case if one has no diffusion). To ensure</span>
            <span class="c1"># fast runtime and compile time, the following if-case avoids the `vmap`</span>
            <span class="c1"># if one does not use diffusion.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">updated_states</span> <span class="o">=</span> <span class="n">step_voltage_implicit</span><span class="p">(</span>
                    <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;linear_terms&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;constant_terms&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;axial_conductances&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                    <span class="n">dt</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Add `vmap` dimension.</span>
                <span class="n">updated_states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">updated_states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nones</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver_kwargs</span><span class="p">)</span>
                <span class="n">vmapped</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
                    <span class="n">step_voltage_implicit</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">nones</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">updated_states</span> <span class="o">=</span> <span class="n">vmapped</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">state_vals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">dt</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;crank_nicolson&quot;</span><span class="p">:</span>
            <span class="c1"># The forward Euler step in Crank-Nicolson can be performed easily as</span>
            <span class="c1"># `V_{n+1} = 2 * V_{n+1/2} - V_n`. See also NEURON book Chapter 4.</span>
            <span class="n">updated_states</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">updated_states</span> <span class="o">-</span> <span class="n">state_vals</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;fwd_euler&quot;</span><span class="p">:</span>
        <span class="n">nones</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">solver_kwargs</span><span class="p">)</span>
        <span class="n">vmapped</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">step_voltage_explicit</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">nones</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">updated_states</span> <span class="o">=</span> <span class="n">vmapped</span><span class="p">(</span>
            <span class="o">*</span><span class="n">state_vals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">*</span><span class="n">solver_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">delta_t</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You specified `solver=</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2">`. The only allowed solvers are &quot;</span>
            <span class="s2">&quot;[&#39;bwd_euler&#39;, &#39;fwd_euler&#39;, &#39;crank_nicolson&#39;].&quot;</span>
        <span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Assign the diffused ion states.</span>
    <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">ion_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diffusion_states</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">ion_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_states</span><span class="p">[</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Clamp for voltages.</span>
    <span class="k">if</span> <span class="s2">&quot;v&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">u</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.stimulate" class="doc doc-heading">
            <code class=" language-python"><span class="n">stimulate</span><span class="p">(</span><span class="n">current</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.stimulate" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a stimulus into the compartment.</p>
<p>current must be a 1d array or have batch dimension of size <code>(num_compartments, )</code>
or <code>(1, )</code>. If 1d, the same stimulus is added to all compartments.</p>
<p>This function cannot be run during <code>jax.jit</code> and <code>jax.grad</code>. Because of this,
it should only be used for static stimuli (i.e., stimuli that do not depend
on the data and that should not be learned). For stimuli that depend on data
(or that should be learned), please use <code>data_stimulate()</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>current</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Current in <code>nA</code>.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">stimulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the compartment.</span>

<span class="sd">    current must be a 1d array or have batch dimension of size `(num_compartments, )`</span>
<span class="sd">    or `(1, )`. If 1d, the same stimulus is added to all compartments.</span>

<span class="sd">    This function cannot be run during `jax.jit` and `jax.grad`. Because of this,</span>
<span class="sd">    it should only be used for static stimuli (i.e., stimuli that do not depend</span>
<span class="sd">    on the data and that should not be learned). For stimuli that depend on data</span>
<span class="sd">    (or that should be learned), please use `data_stimulate()`.</span>

<span class="sd">    Args:</span>
<span class="sd">        current: Current in `nA`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.to_jax" class="doc doc-heading">
            <code class=" language-python"><span class="n">to_jax</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.to_jax" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Move <code>.nodes</code> to <code>.jaxnodes</code>.</p>
<p>Before the actual simulation is run (via <code>jx.integrate</code>), all parameters of
the <code>jx.Module</code> are stored in <code>.nodes</code> (a <code>pd.DataFrame</code>). However, for
simulation, these parameters have to be moved to be <code>jnp.ndarrays</code> such that
they can be processed on GPU/TPU and such that the simulation can be
differentiated. <code>.to_jax()</code> copies the <code>.nodes</code> to <code>.jaxnodes</code>.</p>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@only_allow_module</span>
<span class="k">def</span><span class="w"> </span><span class="nf">to_jax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># TODO FROM #447: Make this work for View?</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move `.nodes` to `.jaxnodes`.</span>

<span class="sd">    Before the actual simulation is run (via `jx.integrate`), all parameters of</span>
<span class="sd">    the `jx.Module` are stored in `.nodes` (a `pd.DataFrame`). However, for</span>
<span class="sd">    simulation, these parameters have to be moved to be `jnp.ndarrays` such that</span>
<span class="sd">    they can be processed on GPU/TPU and such that the simulation can be</span>
<span class="sd">    differentiated. `.to_jax()` copies the `.nodes` to `.jaxnodes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="n">inds</span><span class="p">]</span>

    <span class="c1"># `jaxedges` contains only parameters (no indices).</span>
    <span class="c1"># `jaxedges` contains only non-Nan elements. This is unlike the channels where</span>
    <span class="c1"># we allow parameter sharing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.vis" class="doc doc-heading">
            <code class=" language-python"><span class="n">vis</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.vis" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Visualize the module.</p>
<p>Modules can be visualized on one of the cardinal planes (xy, xz, yz) or
even in 3D.</p>
<p>Several options are available:
- <code>line</code>: All points from the traced morphology (<code>xyzr</code>), are connected
with a line plot.
- <code>scatter</code>: All traced points, are plotted as scatter points.
- <code>comp</code>: Plots the compartmentalized morphology, including radius
and shape. (shows the true compartment lengths per default, but this can
be changed via the <code>kwargs</code>, for details see
<code>jaxley.utils.plot_utils.plot_comps</code>).
- <code>morph</code>: Reconstructs the 3D shape of the traced morphology. For details see
<code>jaxley.utils.plot_utils.plot_morph</code>. Warning: For 3D plots and morphologies
with many traced points this can be very slow.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="matplotlib.axes.Axes">Axes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An axis into which to plot.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color for all branches.</p>
              </div>
            </td>
            <td>
                  <code>&#39;k&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>dims</code>
            </td>
            <td>
                  <code><span title="typing.Tuple">Tuple</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of
two of them.</p>
              </div>
            </td>
            <td>
                  <code>(0, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>type</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The type of plot. One of [&ldquo;line&rdquo;, &ldquo;scatter&rdquo;, &ldquo;comp&rdquo;, &ldquo;morph&rdquo;].</p>
              </div>
            </td>
            <td>
                  <code>&#39;line&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the plotting function.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2364</span>
<span class="normal">2365</span>
<span class="normal">2366</span>
<span class="normal">2367</span>
<span class="normal">2368</span>
<span class="normal">2369</span>
<span class="normal">2370</span>
<span class="normal">2371</span>
<span class="normal">2372</span>
<span class="normal">2373</span>
<span class="normal">2374</span>
<span class="normal">2375</span>
<span class="normal">2376</span>
<span class="normal">2377</span>
<span class="normal">2378</span>
<span class="normal">2379</span>
<span class="normal">2380</span>
<span class="normal">2381</span>
<span class="normal">2382</span>
<span class="normal">2383</span>
<span class="normal">2384</span>
<span class="normal">2385</span>
<span class="normal">2386</span>
<span class="normal">2387</span>
<span class="normal">2388</span>
<span class="normal">2389</span>
<span class="normal">2390</span>
<span class="normal">2391</span>
<span class="normal">2392</span>
<span class="normal">2393</span>
<span class="normal">2394</span>
<span class="normal">2395</span>
<span class="normal">2396</span>
<span class="normal">2397</span>
<span class="normal">2398</span>
<span class="normal">2399</span>
<span class="normal">2400</span>
<span class="normal">2401</span>
<span class="normal">2402</span>
<span class="normal">2403</span>
<span class="normal">2404</span>
<span class="normal">2405</span>
<span class="normal">2406</span>
<span class="normal">2407</span>
<span class="normal">2408</span>
<span class="normal">2409</span>
<span class="normal">2410</span>
<span class="normal">2411</span>
<span class="normal">2412</span>
<span class="normal">2413</span>
<span class="normal">2414</span>
<span class="normal">2415</span>
<span class="normal">2416</span>
<span class="normal">2417</span>
<span class="normal">2418</span>
<span class="normal">2419</span>
<span class="normal">2420</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">    Modules can be visualized on one of the cardinal planes (xy, xz, yz) or</span>
<span class="sd">    even in 3D.</span>

<span class="sd">    Several options are available:</span>
<span class="sd">    - `line`: All points from the traced morphology (`xyzr`), are connected</span>
<span class="sd">    with a line plot.</span>
<span class="sd">    - `scatter`: All traced points, are plotted as scatter points.</span>
<span class="sd">    - `comp`: Plots the compartmentalized morphology, including radius</span>
<span class="sd">    and shape. (shows the true compartment lengths per default, but this can</span>
<span class="sd">    be changed via the `kwargs`, for details see</span>
<span class="sd">    `jaxley.utils.plot_utils.plot_comps`).</span>
<span class="sd">    - `morph`: Reconstructs the 3D shape of the traced morphology. For details see</span>
<span class="sd">    `jaxley.utils.plot_utils.plot_morph`. Warning: For 3D plots and morphologies</span>
<span class="sd">    with many traced points this can be very slow.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax: An axis into which to plot.</span>
<span class="sd">        color: The color for all branches.</span>
<span class="sd">        dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">            two of them.</span>
<span class="sd">        type: The type of plot. One of [&quot;line&quot;, &quot;scatter&quot;, &quot;comp&quot;, &quot;morph&quot;].</span>
<span class="sd">        kwargs: Keyword arguments passed to the plotting function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="s2">&quot;resolution&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;resolution&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;comp&quot;</span> <span class="ow">in</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">plot_comps</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;morph&quot;</span> <span class="ow">in</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">plot_morph</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xyzr</span><span class="p">[:,</span> <span class="n">dims</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">for</span> <span class="n">xyzr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">]</span>
    <span class="p">),</span> <span class="s2">&quot;No coordinates available. Use `vis(detail=&#39;point&#39;)` or run `.compute_xyz()` before running `.vis()`.&quot;</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.write_trainables" class="doc doc-heading">
            <code class=" language-python"><span class="n">write_trainables</span><span class="p">(</span><span class="n">trainable_params</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.write_trainables" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Write the trainables into <code>.nodes</code> and <code>.edges</code>.</p>
<p>This allows to, e.g., visualize trained networks with <code>.vis()</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>trainable_params</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="jax.numpy.ndarray">ndarray</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The trainable parameters returned by <code>get_parameters()</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">write_trainables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trainable_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write the trainables into `.nodes` and `.edges`.</span>

<span class="sd">    This allows to, e.g., visualize trained networks with `.vis()`.</span>

<span class="sd">    Args:</span>
<span class="sd">        trainable_params: The trainable parameters returned by `get_parameters()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We do not support views. Why? `jaxedges` does not have any NaN</span>
    <span class="c1"># elements, whereas edges does. Because of this, we already need special</span>
    <span class="c1"># treatment to make this function work, and it would be an even bigger hassle</span>
    <span class="c1"># if we wanted to support this.</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;Compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Branch&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Cell&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Network&quot;</span><span class="p">,</span>
    <span class="p">],</span> <span class="s2">&quot;Only supports modules.&quot;</span>

    <span class="c1"># We could also implement this without casting the module to jax.</span>
    <span class="c1"># However, I think it allows us to reuse as much code as possible and it avoids</span>
    <span class="c1"># any kind of issues with indexing or parameter sharing (as this is fully</span>
    <span class="c1"># taken care of by `get_all_parameters()`).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">to_jax</span><span class="p">()</span>
    <span class="n">pstate</span> <span class="o">=</span> <span class="n">params_to_pstate</span><span class="p">(</span><span class="n">trainable_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="p">)</span>
    <span class="n">all_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_all_parameters</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">voltage_solver</span><span class="o">=</span><span class="s2">&quot;jaxley.stone&quot;</span><span class="p">)</span>

    <span class="c1"># The value for `delta_t` does not matter here because it is only used to</span>
    <span class="c1"># compute the initial current. However, the initial current cannot be made</span>
    <span class="c1"># trainable and so its value never gets used below.</span>
    <span class="n">all_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_all_states</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="mf">0.025</span><span class="p">)</span>

    <span class="c1"># Loop only over the keys in `pstate` to avoid unnecessary computation.</span>
    <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">vals_to_set</span> <span class="o">=</span> <span class="n">all_params</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">all_states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals_to_set</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1"># `jaxedges` contains only non-Nan elements. This is unlike the channels where</span>
    <span class="c1"># we allow parameter sharing.</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="compartment">Compartment<a class="headerlink" href="#compartment" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.compartment.Compartment"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Compartment class.</p>
<p>This class defines a single compartment that can be simulated by itself or
connected up into branches. It is the basic building block of a neuron model.</p>







              <details class="quote">
                <summary>Source code in <code>jaxley/modules/compartment.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Compartment</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compartment class.</span>

<span class="sd">    This class defines a single compartment that can be simulated by itself or</span>
<span class="sd">    connected up into branches. It is the basic building block of a neuron model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">compartment_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>  <span class="c1"># um</span>
        <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># um</span>
        <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">:</span> <span class="mf">5_000.0</span><span class="p">,</span>  <span class="c1"># ohm cm</span>
        <span class="s2">&quot;capacitance&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># uF/cm^2</span>
    <span class="p">}</span>
    <span class="n">compartment_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">70.0</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>

        <span class="c1"># Setting up the `nodes` for indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">global_cell_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">global_branch_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">global_comp_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compartment_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_states</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

        <span class="c1"># Synapses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">parent_branch_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">child_branch_index</span><span class="o">=</span><span class="p">[])</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Initialize the module.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

        <span class="c1"># Coordinates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jaxley_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solve_indexer</span> <span class="o">=</span> <span class="n">JaxleySolveIndexer</span><span class="p">(</span>
            <span class="n">cumsum_ncomp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">,</span>
            <span class="n">ncomp_per_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
            <span class="n">branchpoint_group_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">children_in_level</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">parents_in_level</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">root_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">remapped_node_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jax_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize morphology for the jax sparse voltage solver.</span>

<span class="sd">        Explanation of `self._comp_eges[&#39;type&#39;]`:</span>
<span class="sd">        `type == 0`: compartment &lt;--&gt; compartment (within branch)</span>
<span class="sd">        `type == 1`: branchpoint --&gt; parent-compartment</span>
<span class="sd">        `type == 2`: branchpoint --&gt; child-compartment</span>
<span class="sd">        `type == 3`: parent-compartment --&gt; branchpoint</span>
<span class="sd">        `type == 4`: child-compartment --&gt; branchpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="p">)</span>
        <span class="n">n_nodes</span><span class="p">,</span> <span class="n">data_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">comp_edges_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_nodes</span> <span class="o">=</span> <span class="n">n_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_inds</span> <span class="o">=</span> <span class="n">data_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_jax_spsolve</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indptr_jax_spsolve</span> <span class="o">=</span> <span class="n">indptr</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><h2 id="branch">Branch<a class="headerlink" href="#branch" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.branch.Branch"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Branch class.</p>
<p>This class defines a single branch that can be simulated by itself or
connected to build a cell. A branch is linear segment of several compartments
and can be connected to no, one or more other branches at each end to build more
intricate cell morphologies.</p>







              <details class="quote">
                <summary>Source code in <code>jaxley/modules/branch.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Branch</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Branch class.</span>

<span class="sd">    This class defines a single branch that can be simulated by itself or</span>
<span class="sd">    connected to build a cell. A branch is linear segment of several compartments</span>
<span class="sd">    and can be connected to no, one or more other branches at each end to build more</span>
<span class="sd">    intricate cell morphologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">branch_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">branch_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compartments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Compartment</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ncomp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            compartments: A single compartment or a list of compartments that make up the</span>
<span class="sd">                branch.</span>
<span class="sd">            ncomp: Number of segments to divide the branch into. If `compartments` is an</span>
<span class="sd">                a single compartment, than the compartment is repeated `ncomp` times to</span>
<span class="sd">                create the branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="p">(</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;Only Compartment or List[Compartment] is allowed.&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">ncomp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;If `compartments` is not a list then you have to set `ncomp`.&quot;</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">Compartment</span><span class="p">()</span> <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">compartments</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">ncomp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ncomp</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
            <span class="n">compartment_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">compartments</span><span class="p">]</span> <span class="o">*</span> <span class="n">ncomp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compartment_list</span> <span class="o">=</span> <span class="n">compartments</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>

        <span class="c1"># Indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartment_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_states</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

        <span class="c1"># Channels.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">parent_branch_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">child_branch_index</span><span class="o">=</span><span class="p">[])</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

        <span class="c1"># Coordinates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jaxley_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solve_indexer</span> <span class="o">=</span> <span class="n">JaxleySolveIndexer</span><span class="p">(</span>
            <span class="n">cumsum_ncomp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">,</span>
            <span class="n">ncomp_per_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
            <span class="n">branchpoint_group_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">remapped_node_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
            <span class="n">children_in_level</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">parents_in_level</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">root_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jax_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize morphology for the jax sparse voltage solver.</span>

<span class="sd">        Explanation of `self._comp_eges[&#39;type&#39;]`:</span>
<span class="sd">        `type == 0`: compartment &lt;--&gt; compartment (within branch)</span>
<span class="sd">        `type == 1`: branchpoint --&gt; parent-compartment</span>
<span class="sd">        `type == 2`: branchpoint --&gt; child-compartment</span>
<span class="sd">        `type == 3`: parent-compartment --&gt; branchpoint</span>
<span class="sd">        `type == 4`: child-compartment --&gt; branchpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)),</span>
                <span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_nodes</span><span class="p">,</span> <span class="n">data_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">comp_edges_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_nodes</span> <span class="o">=</span> <span class="n">n_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_inds</span> <span class="o">=</span> <span class="n">data_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_jax_spsolve</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indptr_jax_spsolve</span> <span class="o">=</span> <span class="n">indptr</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.branch.Branch.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">compartments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ncomp</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.branch.Branch.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>compartments</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.compartment.Compartment" href="#jaxley.modules.compartment.Compartment">Compartment</a>, <span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.compartment.Compartment" href="#jaxley.modules.compartment.Compartment">Compartment</a>]]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A single compartment or a list of compartments that make up the
branch.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ncomp</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of segments to divide the branch into. If <code>compartments</code> is an
a single compartment, than the compartment is repeated <code>ncomp</code> times to
create the branch.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/branch.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">compartments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Compartment</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ncomp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        compartments: A single compartment or a list of compartments that make up the</span>
<span class="sd">            branch.</span>
<span class="sd">        ncomp: Number of segments to divide the branch into. If `compartments` is an</span>
<span class="sd">            a single compartment, than the compartment is repeated `ncomp` times to</span>
<span class="sd">            create the branch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="p">(</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">),</span> <span class="s2">&quot;Only Compartment or List[Compartment] is allowed.&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">ncomp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;If `compartments` is not a list then you have to set `ncomp`.&quot;</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="n">Compartment</span><span class="p">()</span> <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">compartments</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">ncomp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ncomp</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
        <span class="n">compartment_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">compartments</span><span class="p">]</span> <span class="o">*</span> <span class="n">ncomp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">compartment_list</span> <span class="o">=</span> <span class="n">compartments</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>

    <span class="c1"># Indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartment_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_states</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

    <span class="c1"># Channels.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">parent_branch_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">child_branch_index</span><span class="o">=</span><span class="p">[])</span>
    <span class="p">)</span>

    <span class="c1"># For morphology indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="c1"># Coordinates.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="cell">Cell<a class="headerlink" href="#cell" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.cell.Cell"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Cell class.</p>
<p>This class defines a single cell that can be simulated by itself or
connected with synapses to build a network. A cell is made up of several branches
and supports intricate cell morphologies.</p>







              <details class="quote">
                <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Cell</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cell class.</span>

<span class="sd">    This class defines a single cell that can be simulated by itself or</span>
<span class="sd">    connected with synapses to build a network. A cell is made up of several branches</span>
<span class="sd">    and supports intricate cell morphologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cell_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cell_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">branches</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Branch</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parents</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xyzr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            branches: A single branch or a list of branches that make up the cell.</span>
<span class="sd">                If a single branch is provided, then the branch is repeated `len(parents)`</span>
<span class="sd">                times to create the cell.</span>
<span class="sd">            parents: The parent branch index for each branch. The first branch has no</span>
<span class="sd">                parent and is therefore set to -1.</span>
<span class="sd">            xyzr: For every branch, the x, y, and z coordinates and the radius at the</span>
<span class="sd">                traced coordinates. Note that this is the full tracing (from SWC), not</span>
<span class="sd">                the stick representation coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="p">(</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;Only Branch or List[Branch] is allowed.&quot;</span>
        <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">parents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;If `branches` is not a list then you have to set `parents`.&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">branches</span>
            <span class="p">),</span> <span class="s2">&quot;Ensure equally many parents, i.e. len(branches) == len(parents).&quot;</span>

        <span class="n">branches</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">()</span> <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">branches</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">parents</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">Branch</span><span class="p">):</span>
            <span class="n">branch_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">branch_list</span> <span class="o">=</span> <span class="n">branches</span>

        <span class="k">if</span> <span class="n">xyzr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="n">xyzr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For every branch (`len(parents)`), we have a start and end point (`2`) and</span>
            <span class="c1"># a (x,y,z,r) coordinate for each of them (`4`).</span>
            <span class="c1"># Since `xyzr` is only inspected at `.vis()` and because it depends on the</span>
            <span class="c1"># (potentially learned) length of every compartment, we only populate</span>
            <span class="c1"># self.xyzr at `.vis()`.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_children</span> <span class="o">=</span> <span class="n">compute_children_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)])</span>

        <span class="c1"># Compartment structure. These arguments have to be rebuilt when `.set_ncomp()`</span>
        <span class="c1"># is run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">branch</span><span class="o">.</span><span class="n">ncomp</span> <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Build nodes. Has to be changed when `.set_ncomp()` is run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

        <span class="c1"># Appending general parameters (radius, length, r_a, cm) and channel parameters,</span>
        <span class="c1"># as well as the states (v, and channel states).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_states</span><span class="p">)</span>

        <span class="c1"># Channels.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jaxley_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize morphology for the custom sparse solver.</span>

<span class="sd">        Running this function is only required for custom Jaxley solvers, i.e., for</span>
<span class="sd">        `voltage_solver={&#39;jaxley.stone&#39;, &#39;jaxley.thomas&#39;}`. However, because at</span>
<span class="sd">        `.__init__()` (when the function is run), we do not yet know which solver the</span>
<span class="sd">        user will use. Therefore, we always run this function at `.__init__()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_and_parents</span> <span class="o">=</span> <span class="n">compute_morphology_indices_in_levels</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">build_branchpoint_group_inds</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
        <span class="n">children_inds</span> <span class="o">=</span> <span class="n">children_and_parents</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span>
        <span class="n">parents_inds</span> <span class="o">=</span> <span class="n">children_and_parents</span><span class="p">[</span><span class="s2">&quot;parents&quot;</span><span class="p">]</span>

        <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="n">children_in_level</span> <span class="o">=</span> <span class="n">compute_children_in_level</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">children_inds</span><span class="p">)</span>
        <span class="n">parents_in_level</span> <span class="o">=</span> <span class="n">compute_parents_in_level</span><span class="p">(</span>
            <span class="n">levels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="n">parents_inds</span>
        <span class="p">)</span>
        <span class="n">levels_and_ncomp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;levels&quot;</span><span class="p">:</span> <span class="n">levels</span><span class="p">,</span>
                <span class="s2">&quot;ncomps&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">levels_and_ncomp</span><span class="p">[</span><span class="s2">&quot;max_ncomp_in_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">levels_and_ncomp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;levels&quot;</span><span class="p">)[</span>
            <span class="s2">&quot;ncomps&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
        <span class="n">padded_cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span>
            <span class="n">levels_and_ncomp</span><span class="p">[</span><span class="s2">&quot;max_ncomp_in_level&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Generate mapping to deal with the masking which allows using the custom</span>
        <span class="c1"># sparse solver to deal with different ncomp per branch.</span>
        <span class="n">remapped_node_indices</span> <span class="o">=</span> <span class="n">remap_index_to_masked</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">padded_cumsum_ncomp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solve_indexer</span> <span class="o">=</span> <span class="n">JaxleySolveIndexer</span><span class="p">(</span>
            <span class="n">cumsum_ncomp</span><span class="o">=</span><span class="n">padded_cumsum_ncomp</span><span class="p">,</span>
            <span class="n">ncomp_per_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
            <span class="n">branchpoint_group_inds</span><span class="o">=</span><span class="n">branchpoint_group_inds</span><span class="p">,</span>
            <span class="n">children_in_level</span><span class="o">=</span><span class="n">children_in_level</span><span class="p">,</span>
            <span class="n">parents_in_level</span><span class="o">=</span><span class="n">parents_in_level</span><span class="p">,</span>
            <span class="n">root_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">remapped_node_indices</span><span class="o">=</span><span class="n">remapped_node_indices</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jax_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;For morphology indexing with the `jax.sparse` voltage volver.</span>

<span class="sd">        Explanation of `self._comp_eges[&#39;type&#39;]`:</span>
<span class="sd">        `type == 0`: compartment &lt;--&gt; compartment (within branch)</span>
<span class="sd">        `type == 1`: branchpoint --&gt; parent-compartment</span>
<span class="sd">        `type == 2`: branchpoint --&gt; child-compartment</span>
<span class="sd">        `type == 3`: parent-compartment --&gt; branchpoint</span>
<span class="sd">        `type == 4`: child-compartment --&gt; branchpoint</span>

<span class="sd">        Running this function is only required for generic sparse solvers, i.e., for</span>
<span class="sd">        `voltage_solver=&#39;jax.sparse&#39;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Edges between compartments within the branches.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">cumsum_ncomp</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">cumsum_ncomp</span><span class="p">))</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cumsum_ncomp</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">+</span> <span class="n">cumsum_ncomp</span><span class="p">)),</span>
                        <span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cumsum_ncomp</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">+</span> <span class="n">cumsum_ncomp</span><span class="p">))</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">cumsum_ncomp</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">cumsum_ncomp</span><span class="p">)),</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">cumsum_ncomp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Edges from branchpoints to compartments.</span>
        <span class="n">branchpoint_to_parent_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">branchpoint_to_child_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">],</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">,</span>
                <span class="n">branchpoint_to_parent_edges</span><span class="p">,</span>
                <span class="n">branchpoint_to_child_edges</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Edges from compartments to branchpoints.</span>
        <span class="n">parent_to_branchpoint_edges</span> <span class="o">=</span> <span class="n">branchpoint_to_parent_edges</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;sink&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">parent_to_branchpoint_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">child_to_branchpoint_edges</span> <span class="o">=</span> <span class="n">branchpoint_to_child_edges</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;sink&quot;</span><span class="p">:</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;sink&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">child_to_branchpoint_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">,</span>
                <span class="n">parent_to_branchpoint_edges</span><span class="p">,</span>
                <span class="n">child_to_branchpoint_edges</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">n_nodes</span><span class="p">,</span> <span class="n">data_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">comp_edges_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_nodes</span> <span class="o">=</span> <span class="n">n_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_inds</span> <span class="o">=</span> <span class="n">data_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_jax_spsolve</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indptr_jax_spsolve</span> <span class="o">=</span> <span class="n">indptr</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.cell.Cell.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyzr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.cell.Cell.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize a cell.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>branches</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.branch.Branch" href="#jaxley.modules.branch.Branch">Branch</a>, <span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.branch.Branch" href="#jaxley.modules.branch.Branch">Branch</a>]]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A single branch or a list of branches that make up the cell.
If a single branch is provided, then the branch is repeated <code>len(parents)</code>
times to create the cell.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>parents</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="int">int</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The parent branch index for each branch. The first branch has no
parent and is therefore set to -1.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>xyzr</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="numpy.ndarray">ndarray</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>For every branch, the x, y, and z coordinates and the radius at the
traced coordinates. Note that this is the full tracing (from SWC), not
the stick representation coordinates.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Branch</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">parents</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">xyzr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize a cell.</span>

<span class="sd">    Args:</span>
<span class="sd">        branches: A single branch or a list of branches that make up the cell.</span>
<span class="sd">            If a single branch is provided, then the branch is repeated `len(parents)`</span>
<span class="sd">            times to create the cell.</span>
<span class="sd">        parents: The parent branch index for each branch. The first branch has no</span>
<span class="sd">            parent and is therefore set to -1.</span>
<span class="sd">        xyzr: For every branch, the x, y, and z coordinates and the radius at the</span>
<span class="sd">            traced coordinates. Note that this is the full tracing (from SWC), not</span>
<span class="sd">            the stick representation coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="p">(</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">),</span> <span class="s2">&quot;Only Branch or List[Branch] is allowed.&quot;</span>
    <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">parents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;If `branches` is not a list then you have to set `parents`.&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">branches</span>
        <span class="p">),</span> <span class="s2">&quot;Ensure equally many parents, i.e. len(branches) == len(parents).&quot;</span>

    <span class="n">branches</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">()</span> <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">branches</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">parents</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">Branch</span><span class="p">):</span>
        <span class="n">branch_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branch_list</span> <span class="o">=</span> <span class="n">branches</span>

    <span class="k">if</span> <span class="n">xyzr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="n">xyzr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For every branch (`len(parents)`), we have a start and end point (`2`) and</span>
        <span class="c1"># a (x,y,z,r) coordinate for each of them (`4`).</span>
        <span class="c1"># Since `xyzr` is only inspected at `.vis()` and because it depends on the</span>
        <span class="c1"># (potentially learned) length of every compartment, we only populate</span>
        <span class="c1"># self.xyzr at `.vis()`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comb_children</span> <span class="o">=</span> <span class="n">compute_children_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)])</span>

    <span class="c1"># Compartment structure. These arguments have to be rebuilt when `.set_ncomp()`</span>
    <span class="c1"># is run.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">branch</span><span class="o">.</span><span class="n">ncomp</span> <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Build nodes. Has to be changed when `.set_ncomp()` is run.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span>
    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

    <span class="c1"># Appending general parameters (radius, length, r_a, cm) and channel parameters,</span>
    <span class="c1"># as well as the states (v, and channel states).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_states</span><span class="p">)</span>

    <span class="c1"># Channels.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># For morphology indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="network">Network<a class="headerlink" href="#network" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.network.Network"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Network class.</p>
<p>This class defines a network of cells that can be connected with synapses.</p>







              <details class="quote">
                <summary>Source code in <code>jaxley/modules/network.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Network</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Network class.</span>

<span class="sd">    This class defines a network of cells that can be connected with synapses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">network_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">network_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Cell</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize network of cells and synapses.</span>

<span class="sd">        Args:</span>
<span class="sd">            cells: A list of cells that make up the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">+=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span> <span class="o">=</span> <span class="n">cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_states</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">comb_parents</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parents</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="c1"># Two columns: `parent_branch_index` and `child_branch_index`. One row per</span>
        <span class="c1"># branch, apart from those branches which do not have a parent (i.e.</span>
        <span class="c1"># -1 in parents). For every branch, tracks the global index of that branch</span>
        <span class="c1"># (`child_branch_index`) and the global index of its parent</span>
        <span class="c1"># (`parent_branch_index`).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing of both `jax.sparse` and the custom `jaxley` solvers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># `nbranchpoints` in each cell == cell._par_inds (because `par_inds` are unique).</span>
        <span class="n">nbranchpoints</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranchpoints_per_cell</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="n">nbranchpoints</span><span class="p">)</span>

        <span class="c1"># Channels.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="si">}</span><span class="s2"> different channels and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">)</span><span class="si">}</span><span class="s2"> synapses. Use `.nodes` or `.edges` for details.&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jaxley_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">build_branchpoint_group_inds</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">children_in_level</span> <span class="o">=</span> <span class="n">merge_cells</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranchpoints_per_cell</span><span class="p">,</span>
            <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">_solve_indexer</span><span class="o">.</span><span class="n">children_in_level</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span><span class="p">],</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">parents_in_level</span> <span class="o">=</span> <span class="n">merge_cells</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranchpoints_per_cell</span><span class="p">,</span>
            <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">_solve_indexer</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span><span class="p">],</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">padded_cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_solve_indexer</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Generate mapping to dealing with the masking which allows using the custom</span>
        <span class="c1"># sparse solver to deal with different ncomp per branch.</span>
        <span class="n">remapped_node_indices</span> <span class="o">=</span> <span class="n">remap_index_to_masked</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">padded_cumsum_ncomp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solve_indexer</span> <span class="o">=</span> <span class="n">JaxleySolveIndexer</span><span class="p">(</span>
            <span class="n">cumsum_ncomp</span><span class="o">=</span><span class="n">padded_cumsum_ncomp</span><span class="p">,</span>
            <span class="n">ncomp_per_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
            <span class="n">branchpoint_group_inds</span><span class="o">=</span><span class="n">branchpoint_group_inds</span><span class="p">,</span>
            <span class="n">children_in_level</span><span class="o">=</span><span class="n">children_in_level</span><span class="p">,</span>
            <span class="n">parents_in_level</span><span class="o">=</span><span class="n">parents_in_level</span><span class="p">,</span>
            <span class="n">root_inds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">remapped_node_indices</span><span class="o">=</span><span class="n">remapped_node_indices</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_morph_jax_spsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the morphology for networks.</span>

<span class="sd">        The reason that this function is a bit involved for a `Network` is that Jaxley</span>
<span class="sd">        considers branchpoint nodes to be at the very end of __all__ nodes (i.e. the</span>
<span class="sd">        branchpoints of the first cell are even after the compartments of the second</span>
<span class="sd">        cell. The reason for this is that, otherwise, `cumsum_ncomp` becomes tricky).</span>

<span class="sd">        To achieve this, we first loop over all compartments and append them, and then</span>
<span class="sd">        loop over all branchpoints and append those. The code for building the indices</span>
<span class="sd">        from the `comp_edges` is identical to `jx.Cell`.</span>

<span class="sd">        Explanation of `self._comp_eges[&#39;type&#39;]`:</span>
<span class="sd">        `type == 0`: compartment &lt;--&gt; compartment (within branch)</span>
<span class="sd">        `type == 1`: branchpoint --&gt; parent-compartment</span>
<span class="sd">        `type == 2`: branchpoint --&gt; child-compartment</span>
<span class="sd">        `type == 3`: parent-compartment --&gt; branchpoint</span>
<span class="sd">        `type == 4`: child-compartment --&gt; branchpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_ncomp_per_cell</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">cell</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Add all the internal nodes.</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_ncomp_per_cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span><span class="p">):</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">,</span> <span class="p">[</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rows</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># All branchpoint-to-compartment nodes.</span>
        <span class="n">start_branchpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Index of the first branchpoint.</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset_branchpoints</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_ncomp_per_cell</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranchpoints_per_cell</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">offset_within_cell</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">start_branchpoints</span> <span class="o">-</span> <span class="n">offset_within_cell</span> <span class="o">+</span> <span class="n">offset_branchpoints</span><span class="p">,</span>
                        <span class="n">offset</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                    <span class="p">]</span>
                    <span class="o">+</span> <span class="n">rows</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># All compartment-to-branchpoint nodes.</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset_branchpoints</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_ncomp_per_cell</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranchpoints_per_cell</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">offset_within_cell</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">offset</span><span class="p">,</span>
                        <span class="n">start_branchpoints</span> <span class="o">-</span> <span class="n">offset_within_cell</span> <span class="o">+</span> <span class="n">offset_branchpoints</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                    <span class="p">]</span>
                    <span class="o">+</span> <span class="n">rows</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Convert comp_edges to the index format required for `jax.sparse` solvers.</span>
        <span class="n">n_nodes</span><span class="p">,</span> <span class="n">data_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">comp_edges_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_nodes</span> <span class="o">=</span> <span class="n">n_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_inds</span> <span class="o">=</span> <span class="n">data_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_jax_spsolve</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indptr_jax_spsolve</span> <span class="o">=</span> <span class="n">indptr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_synapse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform one step of the synapses and obtain their currents.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_synapse_state</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">syn_channels</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">syn_channels</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">edges</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_synapse_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="n">grouped_syns</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pre_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;pre_global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">post_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;post_global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">synapse_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouped_syns</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">syn_channels</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span>
            <span class="p">),</span> <span class="s2">&quot;Mixup in the ordering of synapses. Please create an issue on Github.&quot;</span>
            <span class="n">synapse_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">synapse_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="n">synapse_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">synapse_param_names</span><span class="p">:</span>
                <span class="n">synapse_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="n">synapse_states</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synapse_state_names</span><span class="p">:</span>
                <span class="n">synapse_states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="n">pre_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pre_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">post_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">post_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># State updates.</span>
            <span class="n">states_updated</span> <span class="o">=</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">update_states</span><span class="p">(</span>
                <span class="n">synapse_states</span><span class="p">,</span>
                <span class="n">delta_t</span><span class="p">,</span>
                <span class="n">voltages</span><span class="p">[</span><span class="n">pre_inds</span><span class="p">],</span>
                <span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">],</span>
                <span class="n">synapse_params</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Rebuild state.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">states_updated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">states</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_synapse_currents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="n">grouped_syns</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pre_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;pre_global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">post_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;post_global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">synapse_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouped_syns</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">syn_voltage_terms</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="n">syn_constant_terms</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="c1"># Run with two different voltages that are `diff` apart to infer the slope and</span>
        <span class="c1"># offset.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">syn_channels</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span>
            <span class="p">),</span> <span class="s2">&quot;Mixup in the ordering of synapses. Please create an issue on Github.&quot;</span>
            <span class="n">synapse_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">synapse_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="n">synapse_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">synapse_param_names</span><span class="p">:</span>
                <span class="n">synapse_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="n">synapse_states</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synapse_state_names</span><span class="p">:</span>
                <span class="n">synapse_states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="c1"># Get pre and post indexes of the current synapse type.</span>
            <span class="n">pre_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pre_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">post_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">post_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># Compute slope and offset of the current through every synapse.</span>
            <span class="n">pre_v_and_perturbed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">voltages</span><span class="p">[</span><span class="n">pre_inds</span><span class="p">],</span> <span class="n">voltages</span><span class="p">[</span><span class="n">pre_inds</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">post_v_and_perturbed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">],</span> <span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">synapse_currents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
                <span class="n">synapse_type</span><span class="o">.</span><span class="n">compute_current</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="p">)(</span>
                <span class="n">synapse_states</span><span class="p">,</span>
                <span class="n">pre_v_and_perturbed</span><span class="p">,</span>
                <span class="n">post_v_and_perturbed</span><span class="p">,</span>
                <span class="n">synapse_params</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">synapse_currents_dist</span> <span class="o">=</span> <span class="n">convert_point_process_to_distributed</span><span class="p">(</span>
                <span class="n">synapse_currents</span><span class="p">,</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">][</span><span class="n">post_inds</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">post_inds</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Split into voltage and constant terms.</span>
            <span class="n">voltage_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_currents_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">synapse_currents_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">diff</span>
            <span class="n">constant_term</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">synapse_currents_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">voltage_term</span> <span class="o">*</span> <span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Gather slope and offset for every postsynaptic compartment.</span>
            <span class="n">gathered_syn_currents</span> <span class="o">=</span> <span class="n">gather_synapes</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">voltages</span><span class="p">),</span>
                <span class="n">post_inds</span><span class="p">,</span>
                <span class="n">voltage_term</span><span class="p">,</span>
                <span class="n">constant_term</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">syn_voltage_terms</span> <span class="o">+=</span> <span class="n">gathered_syn_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">syn_constant_terms</span> <span class="o">-=</span> <span class="n">gathered_syn_currents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Add the synaptic currents through every compartment as state.</span>
            <span class="c1"># `post_syn_currents` is a `jnp.ndarray` of as many elements as there are</span>
            <span class="c1"># compartments in the network.</span>
            <span class="c1"># `[0]` because we only use the non-perturbed voltage.</span>
            <span class="n">states</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;i_</span><span class="si">{</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synapse_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="n">syn_voltage_terms</span><span class="p">,</span> <span class="n">syn_constant_terms</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">arrange_in_layers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">layers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">within_layer_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">500.0</span><span class="p">,</span>
        <span class="n">between_layer_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1500.0</span><span class="p">,</span>
        <span class="n">vertical_layers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Arrange the cells in the network to form layers.</span>

<span class="sd">        Moves the cells in the network to arrange them into layers.</span>

<span class="sd">        Args:</span>
<span class="sd">            layers: List of integers specifying the number of cells in each layer.</span>
<span class="sd">            within_layer_offset: Offset between cells within the same layer.</span>
<span class="sd">            between_layer_offset: Offset between layers.</span>
<span class="sd">            vertical_layers: If True, layers are arranged vertically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;The number of cells in the layers must match the number of cells in the network.&quot;</span>
        <span class="n">cells_in_layers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">[:</span><span class="n">i</span><span class="p">]),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">cell_inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells_in_layers</span><span class="p">):</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vertical_layers</span><span class="p">:</span>
                    <span class="n">x_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">within_layer_offset</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">between_layer_offset</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x_offset</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">between_layer_offset</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">within_layer_offset</span>

                <span class="n">cell</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_offset</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">detail</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">synapse_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">cell_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">synapse_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">synapse_scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>  <span class="c1"># absorb add. kwargs, i.e. to enable net.cell(0).vis(type=&quot;line&quot;)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            detail: Either of [point, full]. `point` visualizes every neuron in the</span>
<span class="sd">                network as a dot.</span>
<span class="sd">                `full` plots the full morphology of every neuron. It requires that</span>
<span class="sd">                `compute_xyz()` has been run.</span>
<span class="sd">            color: The color in which cells are plotted.</span>
<span class="sd">            synapse_color: The color in which synapses are plotted.</span>
<span class="sd">            dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">                two of them.</span>
<span class="sd">            cell_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">                cell morphologies. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">            synapse_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">                syanpses.</span>
<span class="sd">            synapse_scatter_kwargs: Keyword arguments passed to the scatter function for</span>
<span class="sd">                syanpse terminals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">same_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xyz0</span> <span class="o">==</span> <span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">same_xyz</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Same coordinates for all cells. Consider using `move`, `move_to` or `arrange_in_layers` to move them.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>

        <span class="c1"># detail=&quot;point&quot; -&gt; pos taken to be the mean of all traced points on the cell.</span>
        <span class="n">cell_to_point_xyz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dims_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">cell_to_point_xyz</span><span class="p">(</span><span class="n">cell</span><span class="p">)[</span><span class="n">dims_np</span><span class="p">]</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">cell_plot_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">vis</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">cell_plot_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;detail must be in {full, point}.&quot;</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">prepost_locs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">prepost</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">]:</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[[</span><span class="n">prepost</span> <span class="o">+</span> <span class="s2">&quot;_locs&quot;</span><span class="p">,</span> <span class="n">prepost</span> <span class="o">+</span> <span class="s2">&quot;_global_comp_index&quot;</span><span class="p">]]</span>
                <span class="n">branch</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span>
                <span class="n">branch_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">branch</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>

                <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">branch_xyz</span>
                <span class="k">if</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
                    <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">cell_to_point_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_xyz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># If only start and end point of a branch are traced, perform a</span>
                    <span class="c1"># linear interpolation to get the synpase location.</span>
                    <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">branch_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">branch_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">branch_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">loc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If densely traced, use intermediate trace values for synapse loc.</span>
                    <span class="n">middle_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_xyz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">loc</span><span class="p">)</span>
                    <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">xyz_loc</span><span class="p">[</span><span class="n">middle_ind</span><span class="p">]</span>

                <span class="n">prepost_locs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz_loc</span><span class="p">)</span>
            <span class="n">prepost_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">prepost_locs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">prepost_locs</span><span class="p">[</span><span class="n">dims_np</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">synapse_color</span><span class="p">,</span> <span class="o">**</span><span class="n">synapse_plot_kwargs</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="o">*</span><span class="n">prepost_locs</span><span class="p">[</span><span class="n">dims_np</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">synapse_color</span><span class="p">,</span> <span class="o">**</span><span class="n">synapse_scatter_kwargs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_infer_synapse_type_ind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_name</span><span class="p">):</span>
        <span class="n">syn_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_names</span>
        <span class="n">is_new_type</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">synapse_name</span> <span class="ow">in</span> <span class="n">syn_names</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="n">type_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_new_type</span> <span class="k">else</span> <span class="n">syn_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">synapse_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">type_ind</span><span class="p">,</span> <span class="n">is_new_type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_synapse_state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_type</span><span class="p">):</span>
        <span class="c1"># (Potentially) update variables that track meta information about synapses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_state_names</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapse_type</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_append_multiple_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_nodes</span><span class="p">,</span> <span class="n">post_nodes</span><span class="p">,</span> <span class="n">synapse_type</span><span class="p">):</span>
        <span class="c1"># Add synapse types to the module and infer their unique identifier.</span>
        <span class="n">synapse_name</span> <span class="o">=</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span>
        <span class="n">synapse_current_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;i_</span><span class="si">{</span><span class="n">synapse_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">type_ind</span><span class="p">,</span> <span class="n">is_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_synapse_type_ind</span><span class="p">(</span><span class="n">synapse_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_new</span><span class="p">:</span>  <span class="c1"># synapse is not known</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_synapse_state_names</span><span class="p">(</span><span class="n">synapse_type</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">synapse_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapse_current_name</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_nodes</span><span class="p">))]</span>
        <span class="n">global_edge_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;global_edge_index&quot;</span><span class="p">:</span> <span class="n">indices</span><span class="p">})</span>
        <span class="n">post_loc</span> <span class="o">=</span> <span class="n">loc_of_index</span><span class="p">(</span>
            <span class="n">post_nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="n">post_nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pre_loc</span> <span class="o">=</span> <span class="n">loc_of_index</span><span class="p">(</span>
            <span class="n">pre_nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="n">pre_nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Define new synapses. Each row is one synapse.</span>
        <span class="n">pre_nodes</span> <span class="o">=</span> <span class="n">pre_nodes</span><span class="p">[[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]]</span>
        <span class="n">pre_nodes</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pre_global_comp_index&quot;</span><span class="p">]</span>
        <span class="n">post_nodes</span> <span class="o">=</span> <span class="n">post_nodes</span><span class="p">[[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]]</span>
        <span class="n">post_nodes</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;post_global_comp_index&quot;</span><span class="p">]</span>
        <span class="n">new_rows</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">global_edge_index</span><span class="p">,</span>
                <span class="n">pre_nodes</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">post_nodes</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_rows</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synapse_name</span>
        <span class="n">new_rows</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_ind</span>
        <span class="n">new_rows</span><span class="p">[</span><span class="s2">&quot;pre_locs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_loc</span>
        <span class="n">new_rows</span><span class="p">[</span><span class="s2">&quot;post_locs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">post_loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">concat_and_ignore_empty</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">new_rows</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_params_to_edges</span><span class="p">(</span><span class="n">synapse_type</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_in_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_params_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synapse_type</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="c1"># Add parameters and states to the `.edges` table.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">param_val</span> <span class="ow">in</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_val</span>

        <span class="c1"># Update synaptic state array.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">state_val</span> <span class="ow">in</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_val</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span></code>

<a href="#jaxley.modules.network.Network.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize network of cells and synapses.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>cells</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.cell.Cell" href="#jaxley.modules.cell.Cell">Cell</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of cells that make up the network.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Cell</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize network of cells and synapses.</span>

<span class="sd">    Args:</span>
<span class="sd">        cells: A list of cells that make up the network.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">+=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span> <span class="o">=</span> <span class="n">cells</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">ncomp_per_branch</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_internal_node_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_states</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp_per_branch</span>
    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">cumsum_ncomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_local_indices</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_init_view</span><span class="p">()</span>

    <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">comb_parents</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranches</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parents</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="c1"># Two columns: `parent_branch_index` and `child_branch_index`. One row per</span>
    <span class="c1"># branch, apart from those branches which do not have a parent (i.e.</span>
    <span class="c1"># -1 in parents). For every branch, tracks the global index of that branch</span>
    <span class="c1"># (`child_branch_index`) and the global index of its parent</span>
    <span class="c1"># (`parent_branch_index`).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># For morphology indexing of both `jax.sparse` and the custom `jaxley` solvers.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">compute_children_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># `nbranchpoints` in each cell == cell._par_inds (because `par_inds` are unique).</span>
    <span class="n">nbranchpoints</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">_par_inds</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_nbranchpoints_per_cell</span> <span class="o">=</span> <span class="n">cumsum_leading_zero</span><span class="p">(</span><span class="n">nbranchpoints</span><span class="p">)</span>

    <span class="c1"># Channels.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cells_list</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.arrange_in_layers" class="doc doc-heading">
            <code class=" language-python"><span class="n">arrange_in_layers</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="n">within_layer_offset</span><span class="o">=</span><span class="mf">500.0</span><span class="p">,</span> <span class="n">between_layer_offset</span><span class="o">=</span><span class="mf">1500.0</span><span class="p">,</span> <span class="n">vertical_layers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.network.Network.arrange_in_layers" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Arrange the cells in the network to form layers.</p>
<p>Moves the cells in the network to arrange them into layers.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>layers</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of integers specifying the number of cells in each layer.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>within_layer_offset</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Offset between cells within the same layer.</p>
              </div>
            </td>
            <td>
                  <code>500.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>between_layer_offset</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Offset between layers.</p>
              </div>
            </td>
            <td>
                  <code>1500.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>vertical_layers</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, layers are arranged vertically.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">arrange_in_layers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">layers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">within_layer_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">500.0</span><span class="p">,</span>
    <span class="n">between_layer_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1500.0</span><span class="p">,</span>
    <span class="n">vertical_layers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arrange the cells in the network to form layers.</span>

<span class="sd">    Moves the cells in the network to arrange them into layers.</span>

<span class="sd">    Args:</span>
<span class="sd">        layers: List of integers specifying the number of cells in each layer.</span>
<span class="sd">        within_layer_offset: Offset between cells within the same layer.</span>
<span class="sd">        between_layer_offset: Offset between layers.</span>
<span class="sd">        vertical_layers: If True, layers are arranged vertically.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">),</span> <span class="s2">&quot;The number of cells in the layers must match the number of cells in the network.&quot;</span>
    <span class="n">cells_in_layers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">[:</span><span class="n">i</span><span class="p">]),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">layers</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">cell_inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells_in_layers</span><span class="p">):</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vertical_layers</span><span class="p">:</span>
                <span class="n">x_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">within_layer_offset</span>
                <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">between_layer_offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_offset</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">between_layer_offset</span>
                <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">within_layer_offset</span>

            <span class="n">cell</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_offset</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.vis" class="doc doc-heading">
            <code class=" language-python"><span class="n">vis</span><span class="p">(</span><span class="n">detail</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">synapse_color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cell_plot_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">synapse_plot_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">synapse_scatter_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

<a href="#jaxley.modules.network.Network.vis" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Visualize the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>detail</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Either of [point, full]. <code>point</code> visualizes every neuron in the
network as a dot.
<code>full</code> plots the full morphology of every neuron. It requires that
<code>compute_xyz()</code> has been run.</p>
              </div>
            </td>
            <td>
                  <code>&#39;full&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color in which cells are plotted.</p>
              </div>
            </td>
            <td>
                  <code>&#39;k&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>synapse_color</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color in which synapses are plotted.</p>
              </div>
            </td>
            <td>
                  <code>&#39;b&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>dims</code>
            </td>
            <td>
                  <code><span title="typing.Tuple">Tuple</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of
two of them.</p>
              </div>
            </td>
            <td>
                  <code>(0, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>cell_plot_kwargs</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the plotting function for
cell morphologies. Only takes effect for <code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>synapse_plot_kwargs</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the plotting function for
syanpses.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>synapse_scatter_kwargs</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the scatter function for
syanpse terminals.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">detail</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">synapse_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">cell_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">synapse_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">synapse_scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>  <span class="c1"># absorb add. kwargs, i.e. to enable net.cell(0).vis(type=&quot;line&quot;)</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        detail: Either of [point, full]. `point` visualizes every neuron in the</span>
<span class="sd">            network as a dot.</span>
<span class="sd">            `full` plots the full morphology of every neuron. It requires that</span>
<span class="sd">            `compute_xyz()` has been run.</span>
<span class="sd">        color: The color in which cells are plotted.</span>
<span class="sd">        synapse_color: The color in which synapses are plotted.</span>
<span class="sd">        dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">            two of them.</span>
<span class="sd">        cell_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">            cell morphologies. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">        synapse_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">            syanpses.</span>
<span class="sd">        synapse_scatter_kwargs: Keyword arguments passed to the scatter function for</span>
<span class="sd">            syanpse terminals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">same_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xyz0</span> <span class="o">==</span> <span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">same_xyz</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Same coordinates for all cells. Consider using `move`, `move_to` or `arrange_in_layers` to move them.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>

    <span class="c1"># detail=&quot;point&quot; -&gt; pos taken to be the mean of all traced points on the cell.</span>
    <span class="n">cell_to_point_xyz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">cell</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">dims_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">cell_to_point_xyz</span><span class="p">(</span><span class="n">cell</span><span class="p">)[</span><span class="n">dims_np</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">cell_plot_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">vis</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">cell_plot_kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;detail must be in {full, point}.&quot;</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">prepost_locs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">prepost</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span> <span class="s2">&quot;post&quot;</span><span class="p">]:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[[</span><span class="n">prepost</span> <span class="o">+</span> <span class="s2">&quot;_locs&quot;</span><span class="p">,</span> <span class="n">prepost</span> <span class="o">+</span> <span class="s2">&quot;_global_comp_index&quot;</span><span class="p">]]</span>
            <span class="n">branch</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span>
            <span class="n">branch_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">branch</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>

            <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">branch_xyz</span>
            <span class="k">if</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
                <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">cell_to_point_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_xyz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># If only start and end point of a branch are traced, perform a</span>
                <span class="c1"># linear interpolation to get the synpase location.</span>
                <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">branch_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">branch_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">branch_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">loc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If densely traced, use intermediate trace values for synapse loc.</span>
                <span class="n">middle_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_xyz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">loc</span><span class="p">)</span>
                <span class="n">xyz_loc</span> <span class="o">=</span> <span class="n">xyz_loc</span><span class="p">[</span><span class="n">middle_ind</span><span class="p">]</span>

            <span class="n">prepost_locs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz_loc</span><span class="p">)</span>
        <span class="n">prepost_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">prepost_locs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">prepost_locs</span><span class="p">[</span><span class="n">dims_np</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">synapse_color</span><span class="p">,</span> <span class="o">**</span><span class="n">synapse_plot_kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="o">*</span><span class="n">prepost_locs</span><span class="p">[</span><span class="n">dims_np</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">synapse_color</span><span class="p">,</span> <span class="o">**</span><span class="n">synapse_scatter_kwargs</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>